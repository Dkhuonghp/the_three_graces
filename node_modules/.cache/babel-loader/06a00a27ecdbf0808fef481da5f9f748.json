{"ast":null,"code":"import * as THREE from 'three';\nimport * as React from 'react';\nimport create from 'zustand';\nimport shallow from 'zustand/shallow';\nimport Reconciler from 'react-reconciler';\nimport { unstable_now, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';\nimport { useAsset } from 'use-asset';\nimport mergeRefs from 'react-merge-refs';\nimport useMeasure from 'react-use-measure';\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n\n  equ(a, b) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    let i;\n\n    for (i in a) if (!(i in b)) return false;\n\n    for (i in b) if (a[i] !== b[i]) return false;\n\n    return is.und(i) ? a === b : true;\n  }\n\n};\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState(); // Removes every trace of an object from the data store\n\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      internal.hovered.delete(key);\n    }\n  });\n}\n\nfunction createEvents(store) {\n  const temp = new THREE.Vector3();\n  /** Sets up defaultRaycaster */\n\n  function prepareRay(event) {\n    var _raycaster$computeOff;\n\n    const state = store.getState();\n    const {\n      raycaster,\n      mouse,\n      camera,\n      size\n    } = state; // https://github.com/pmndrs/react-three-fiber/pull/782\n    // Events trigger outside of canvas when moved\n\n    const {\n      offsetX,\n      offsetY\n    } = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event;\n    const {\n      width,\n      height\n    } = size;\n    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\n    raycaster.setFromCamera(mouse, camera);\n  }\n  /** Calculates delta */\n\n\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n\n\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n\n  function intersect(filter) {\n    const state = store.getState();\n    const {\n      raycaster,\n      internal\n    } = state; // Skip event handling when noEvents is set\n\n    if (!raycaster.enabled) return [];\n    const seen = new Set();\n    const intersections = []; // Allow callers to eliminate event objects\n\n    const eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates\n\n    let intersects = raycaster.intersectObjects(eventsObjects, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    }); // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order\n\n    if (raycaster.filter) intersects = raycaster.filter(intersects, state);\n\n    for (const intersect of intersects) {\n      let eventObject = intersect.object; // Bubble event up\n\n      while (eventObject) {\n        var _r3f2;\n\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.handlers.count) intersections.push({ ...intersect,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    return intersections;\n  }\n  /**  Creates filtered intersects and returns an array of positive hits */\n\n\n  function patchIntersects(intersections, event) {\n    const {\n      internal\n    } = store.getState(); // If the interaction is captured, make all capturing targets  part of the\n    // intersect.\n\n    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n      intersections.push(...internal.capturedMap.get(event.pointerId).values());\n    }\n\n    return intersections;\n  }\n  /**  Handles intersections by forwarding them to handlers */\n\n\n  function handleIntersects(intersections, event, delta, callback) {\n    const {\n      raycaster,\n      mouse,\n      camera,\n      internal\n    } = store.getState(); // If anything has been found, forward it to the event listeners\n\n    if (intersections.length) {\n      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);\n\n      const releasePointerCapture = id => event.target.releasePointerCapture(id);\n\n      const localState = {\n        stopped: false\n      };\n\n      for (const hit of intersections) {\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n\n        const setPointerCapture = id => {\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, hit);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));\n          } // Call the original event now\n\n\n          event.target.setPointerCapture(id);\n        }; // Add native event props\n\n\n        let extractEventProps = {};\n\n        for (let prop in Object.getPrototypeOf(event)) {\n          let property = event[prop]; // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n\n        let raycastEvent = { ...hit,\n          ...extractEventProps,\n          spaceX: mouse.x,\n          spaceY: mouse.y,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...\n\n            if ( // ...if this pointer hasn't been captured\n            !capturesForPointer || // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          sourceEvent: event,\n          // deprecated\n          nativeEvent: event\n        }; // Call subscribers\n\n        callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation\n\n        if (localState.stopped === true) break;\n      }\n    }\n\n    return intersections;\n  }\n\n  function cancelPointer(hits) {\n    const {\n      internal\n    } = store.getState();\n    Array.from(internal.hovered.values()).forEach(hoveredObj => {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!hits.length || !hits.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        var _r3f3;\n\n        const eventObject = hoveredObj.eventObject;\n        const handlers = (_r3f3 = eventObject.__r3f) == null ? void 0 : _r3f3.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n\n        if (handlers != null && handlers.count) {\n          // Clear out intersects, they are outdated by now\n          const data = { ...hoveredObj,\n            intersections: hits || []\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    });\n  }\n\n  const handlePointer = name => {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n\n      case 'onLostPointerCapture':\n        return event => {\n          if ('pointerId' in event) {\n            // this will be a problem if one target releases the pointerId\n            // and another one is still keeping it, as the line below\n            // indifferently deletes all capturing references.\n            store.getState().internal.capturedMap.delete(event.pointerId);\n          }\n\n          cancelPointer([]);\n        };\n    } // Any other pointer goes here ...\n\n\n    return event => {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n      prepareRay(event); // Get fresh intersects\n\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = patchIntersects(intersect(filter), event);\n      const delta = isClickEvent ? calculateDistance(event) : 0; // Save initial coordinates on pointer-down\n\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      } // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n\n\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      } // Take care of unhover\n\n\n      if (isPointerMove) cancelPointer(hits);\n      handleIntersects(hits, event, delta, data => {\n        var _r3f4;\n\n        const eventObject = data.eventObject;\n        const handlers = (_r3f4 = eventObject.__r3f) == null ? void 0 : _r3f4.handlers; // Check presence of handlers\n\n        if (!(handlers != null && handlers.count)) return;\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          } // Call mouse move\n\n\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (name !== 'onClick' && name !== 'onContextMenu' && name !== 'onDoubleClick' || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object))); // Now call the handler\n\n              handler(data);\n            }\n          }\n        }\n      });\n    };\n  };\n\n  function pointerMissed(event, objects) {\n    objects.forEach(object => {\n      var _r3f5;\n\n      return (_r3f5 = object.__r3f) == null ? void 0 : _r3f5.handlers.onPointerMissed == null ? void 0 : _r3f5.handlers.onPointerMissed(event);\n    });\n  }\n\n  return {\n    handlePointer\n  };\n}\n\nconst isDiffSet = def => def && !!def.memoized && !!def.changes; // Type guard to tell a store from a portal\n\n\nconst isStore = def => def && !!def.getState;\n\nconst getContainer = (container, child) => {\n  var _container$__r3f$root, _container$__r3f;\n\n  return {\n    // If the container is not a root-store then it must be a THREE.Object3D into which part of the\n    // scene is portalled into. Now there can be two variants of this, either that object is part of\n    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies\n    // outside react, in which case we must take the root of the child that is about to be attached to it.\n    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,\n    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D\n    container: isStore(container) ? container.getState().scene : container\n  };\n};\n\nconst DEFAULT = '__default';\nconst EMPTY = {};\nlet catalogue = {};\n\nlet extend = objects => void (catalogue = { ...catalogue,\n  ...objects\n}); // Shallow check arrays, but check objects atomically\n\n\nfunction checkShallow(a, b) {\n  if (is.arr(a) && is.equ(a, b)) return true;\n  if (a === b) return true;\n  return false;\n} // Each object in the scene carries a small LocalState descriptor\n\n\nfunction prepare(object, state) {\n  const instance = object;\n\n  if (state != null && state.primitive || !instance.__r3f) {\n    instance.__r3f = {\n      root: null,\n      memoizedProps: {},\n      handlers: {\n        count: 0\n      },\n      objects: [],\n      parent: null,\n      ...state\n    };\n  }\n\n  return object;\n}\n\nfunction createRenderer(roots) {\n  // This function prepares a set of changes to be applied to the instance\n  function diffProps(instance, _ref2) {\n    let {\n      children: cN,\n      key: kN,\n      ref: rN,\n      ...props\n    } = _ref2;\n    let {\n      children: cP,\n      key: kP,\n      ref: rP,\n      ...previous\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let accumulative = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    var _instance$__r3f;\n\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = []; // Catch removed props, prepend them so they can be reset or removed\n\n    if (accumulative) {\n      const previousKeys = Object.keys(previous);\n\n      for (let i = 0; i < previousKeys.length; i++) if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([previousKeys[i], DEFAULT + 'remove']);\n    }\n\n    entries.forEach(_ref3 => {\n      let [key, value] = _ref3;\n\n      var _instance$__r3f2; // Bail out on primitive object\n\n\n      if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === 'object') return; // When props match bail out\n\n      if (checkShallow(value, previous[key])) return; // Collect handlers and bail out\n\n      if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([key, value, true, []]); // Split dashed props\n\n      let entries = [];\n      if (key.includes('-')) entries = key.split('-');\n      changes.push([key, value, false, entries]);\n    });\n    const memoized = { ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n      accumulative,\n      memoized,\n      changes\n    };\n  }\n\n  function applyProps(instance, data) {\n    var _instance$__r3f3, _root$getState, _localState$handlers, _localState$handlers2, _instance$__r3f4; // Filter equals, events and reserved props\n\n\n    const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const {\n      memoized,\n      changes\n    } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = (_localState$handlers = localState.handlers) == null ? void 0 : _localState$handlers.count; // Prepare memoized props\n\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    changes.forEach(_ref4 => {\n      let [key, value, isEvent, keys] = _ref4;\n      let currentInstance = instance;\n      let targetProp = currentInstance[key]; // Revolve dashed props\n\n      if (keys.length) {\n        targetProp = keys.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\n\n        if (!(targetProp && targetProp.set)) {\n          const [name, ...reverseEntries] = keys.reverse();\n          currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n          key = name;\n        }\n      } // https://github.com/mrdoob/three.js/issues/21209\n      // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n      // has no means to do this. Hence we curate a small collection of value-classes\n      // with their respective constructor/set arguments\n      // For removed props, try to set default values, if possible\n\n\n      if (value === DEFAULT + 'remove') {\n        if (targetProp && targetProp.constructor) {\n          // use the prop constructor to find the default it should be\n          value = new targetProp.constructor(memoized.args);\n        } else if (currentInstance.constructor) {\n          // create a blank slate of the instance and copy the particular parameter.\n          // @ts-ignore\n          const defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);\n          value = defaultClassCall[targetProp]; // destory the instance\n\n          if (defaultClassCall.dispose) defaultClassCall.dispose(); // instance does not have constructor, just set it to 0\n        } else value = 0;\n      } // Deal with pointer events ...\n\n\n      if (isEvent) {\n        if (value) localState.handlers[key] = value;else delete localState.handlers[key];\n        localState.handlers.count = Object.keys(localState.handlers).length;\n      } // Special treatment for objects with support for set/copy, and layers\n      else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE.Layers)) {\n        // If value is an array\n        if (Array.isArray(value)) {\n          if (targetProp.fromArray) targetProp.fromArray(value);else targetProp.set(...value);\n        } // Test again target.copy(class) next ...\n        else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) targetProp.copy(value); // If nothing else fits, just set the single value, ignore undefined\n        // https://github.com/react-spring/react-three-fiber/issues/274\n        else if (value !== undefined) {\n          const isColor = targetProp instanceof THREE.Color; // Allow setting array scalars\n\n          if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property\n          else if (targetProp instanceof THREE.Layers && value instanceof THREE.Layers) targetProp.mask = value.mask; // Otherwise just set ...\n          else targetProp.set(value); // Auto-convert sRGB colors, for now ...\n          // https://github.com/react-spring/react-three-fiber/issues/344\n\n          if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();\n        } // Else, just overwrite the value\n\n      } else {\n        currentInstance[key] = value; // Auto-convert sRGB textures, for now ...\n        // https://github.com/react-spring/react-three-fiber/issues/344\n\n        if (!rootState.linear && currentInstance[key] instanceof THREE.Texture) currentInstance[key].encoding = THREE.sRGBEncoding;\n      }\n\n      invalidateInstance(instance);\n    });\n\n    if (rootState.internal && instance.raycast && prevHandlers !== ((_localState$handlers2 = localState.handlers) == null ? void 0 : _localState$handlers2.count)) {\n      // Pre-emptively remove the instance from the interaction manager\n      const index = rootState.internal.interaction.indexOf(instance);\n      if (index > -1) rootState.internal.interaction.splice(index, 1); // Add the instance to the interaction manager only when it has handlers\n\n      if (localState.handlers.count) rootState.internal.interaction.push(instance);\n    } // Call the update lifecycle when it is being updated\n\n\n    if (changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n  }\n\n  function invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n  }\n\n  function updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n  }\n\n  function createInstance(type, _ref5, root, hostContext, internalInstanceHandle) {\n    let {\n      args = [],\n      ...props\n    } = _ref5;\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance; // https://github.com/facebook/react/issues/17147\n    // Portals do not give us a root, they are themselves treated as a root by the reconciler\n    // In order to figure out the actual root we have to climb through fiber internals :(\n\n    if (!isStore(root) && internalInstanceHandle) {\n      const fn = node => {\n        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);\n      };\n\n      root = fn(internalInstanceHandle);\n    } // Assert that by now we have a valid root\n\n\n    if (!root || !isStore(root)) throw `No valid root for ${name}!`;\n\n    if (type === 'primitive') {\n      if (props.object === undefined) throw `Primitives without 'object' are invalid!`;\n      const object = props.object;\n      instance = prepare(object, {\n        root,\n        primitive: true\n      });\n    } else {\n      const target = catalogue[name] || THREE[name];\n      if (!target) throw `${name} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`; // Instanciate new object, link it to the root\n      // Append memoized props with args so it's not forgotten\n\n      instance = prepare(new target(...args), {\n        root,\n        memoizedProps: {\n          args: args.length === 0 ? null : args\n        }\n      });\n    } // Auto-attach geometries and materials\n\n\n    if (!('attachFns' in props)) {\n      if (name.endsWith('Geometry')) {\n        props = {\n          attach: 'geometry',\n          ...props\n        };\n      } else if (name.endsWith('Material')) {\n        props = {\n          attach: 'material',\n          ...props\n        };\n      }\n    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n\n\n    applyProps(instance, props);\n    return instance;\n  }\n\n  function appendChild(parentInstance, child) {\n    let addedAsChild = false;\n\n    if (child) {\n      // The attach attribute implies that the object attaches itself on the parent\n      if (child.attachArray) {\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n        parentInstance[child.attachArray].push(child);\n      } else if (child.attachObject) {\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = child;\n      } else if (is.arr(child.attachFns)) {\n        const [attachFn] = child.attachFns;\n\n        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {\n          parentInstance[attachFn](child);\n        } else if (is.fun(attachFn)) {\n          attachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        addedAsChild = true;\n      }\n\n      if (!addedAsChild) {\n        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n        // that is, anything that's a child in React but not a child in the scenegraph.\n        parentInstance.__r3f.objects.push(child);\n      }\n\n      if (!child.__r3f) {\n        prepare(child, {});\n      }\n\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n\n    if (child) {\n      if (child.attachArray) {\n        const array = parentInstance[child.attachArray];\n        if (!is.arr(array)) parentInstance[child.attachArray] = [];\n        array.splice(array.indexOf(beforeChild), 0, child);\n      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {\n        // attach and attachObject don't have an order anyway, so just append\n        return appendChild(parentInstance, child);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n\n      if (!added) {\n        parentInstance.__r3f.objects.push(child);\n      }\n\n      if (!child.__r3f) {\n        prepare(child, {});\n      }\n\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function removeRecursive(array, parent) {\n    let dispose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _parentInstance$__r3f, _child$__r3f2;\n\n      if (child.__r3f) {\n        child.__r3f.parent = null;\n      }\n\n      if ((_parentInstance$__r3f = parentInstance.__r3f) != null && _parentInstance$__r3f.objects) {\n        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n      } // Remove attachment\n\n\n      if (child.attachArray) {\n        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);\n      } else if (child.attachObject) {\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = null;\n      } else if (is.arr(child.attachFns)) {\n        const [, detachFn] = child.attachFns;\n\n        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {\n          parentInstance[detachFn](child);\n        } else if (is.fun(detachFn)) {\n          detachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        var _child$__r3f;\n\n        parentInstance.remove(child); // Remove interactivity\n\n        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {\n          removeInteractivity(child.__r3f.root, child);\n        }\n      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be a <primitive object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n\n\n      const isPrimitive = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.primitive;\n      const shouldDispose = dispose === undefined ? child.dispose !== null && !isPrimitive : dispose; // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n\n      if (!isPrimitive) {\n        var _child$__r3f3;\n\n        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      } // Remove references\n\n\n      if (child.__r3f) {\n        delete child.__r3f.root;\n        delete child.__r3f.objects;\n        delete child.__r3f.handlers;\n        delete child.__r3f.memoizedProps;\n        if (!isPrimitive) delete child.__r3f;\n      } // Dispose item whenever the reconciler feels like it\n\n\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        unstable_runWithPriority(unstable_IdlePriority, () => {\n          try {\n            child.dispose();\n          } catch (e) {\n            /* ... */\n          }\n        });\n      }\n\n      invalidateInstance(parentInstance);\n    }\n  }\n\n  function switchInstance(instance, type, newProps, fiber) {\n    var _instance$__r3f6;\n\n    const parent = (_instance$__r3f6 = instance.__r3f) == null ? void 0 : _instance$__r3f6.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n    // This can not include primitives, which should not have declarative children\n\n    if (type !== 'primitive' && instance.children) {\n      instance.children.forEach(child => appendChild(newInstance, child));\n      instance.children = [];\n    }\n\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n\n    instance.__r3f.objects = [];\n    removeChild(parent, instance);\n    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n    // https://github.com/facebook/react/issues/14983\n    // https://github.com/facebook/react/pull/15021\n    ;\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n\n  const reconciler = Reconciler({\n    now: unstable_now,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    warnsIfNotActing: true,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    // @ts-ignore\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    // @ts-ignore\n    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    noTimeout: -1,\n    appendChildToContainer: (parentInstance, child) => {\n      const {\n        container,\n        root\n      } = getContainer(parentInstance, child); // Link current root to the default scene\n\n      container.__r3f.root = root;\n      appendChild(container, child);\n    },\n    removeChildFromContainer: (parentInstance, child) => removeChild(getContainer(parentInstance, child).container, child),\n    insertInContainerBefore: (parentInstance, child, beforeChild) => insertBefore(getContainer(parentInstance, child).container, child, beforeChild),\n\n    prepareUpdate(instance, type, oldProps, newProps) {\n      if (instance.__r3f.primitive && newProps.object && newProps.object !== instance) return [true];else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          children: cN,\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          children: cO,\n          ...restOld\n        } = oldProps; // If it has new props or arguments, then it needs to be re-instanciated\n\n        if (argsNew.some((value, index) => value !== argsOld[index])) return [true]; // Create a diff-set, flag if there are any changes\n\n        const diff = diffProps(instance, restNew, restOld, true);\n        if (diff.changes.length) return [false, diff]; // Otherwise do not touch the instance\n\n        return null;\n      }\n    },\n\n    commitUpdate(instance, _ref6, type, oldProps, newProps, fiber) {\n      let [reconstruct, diff] = _ref6;\n      // Reconstruct when args or <primitive object={...} have changes\n      if (reconstruct) switchInstance(instance, type, newProps, fiber); // Otherwise just overwrite props\n      else applyProps(instance, diff);\n    },\n\n    hideInstance(instance) {\n      if (instance.isObject3D) {\n        instance.visible = false;\n        invalidateInstance(instance);\n      }\n    },\n\n    unhideInstance(instance, props) {\n      if (instance.isObject3D && props.visible == null || props.visible) {\n        instance.visible = true;\n        invalidateInstance(instance);\n      }\n    },\n\n    hideTextInstance() {\n      throw new Error('Text is not allowed in the R3F tree.');\n    },\n\n    getPublicInstance(instance) {\n      // TODO: might fix switchInstance (?)\n      return instance;\n    },\n\n    getRootHostContext(rootContainer) {\n      return EMPTY;\n    },\n\n    getChildHostContext(parentHostContext) {\n      return parentHostContext;\n    },\n\n    createTextInstance() {},\n\n    finalizeInitialChildren() {\n      return false;\n    },\n\n    commitMount() {// noop\n    },\n\n    shouldDeprioritizeSubtree() {\n      return false;\n    },\n\n    prepareForCommit() {\n      return null;\n    },\n\n    preparePortalMount(containerInfo) {\n      prepare(containerInfo);\n    },\n\n    resetAfterCommit() {// noop\n    },\n\n    shouldSetTextContent() {\n      return false;\n    },\n\n    clearContainer() {\n      return false;\n    }\n\n  });\n  return {\n    reconciler,\n    applyProps\n  };\n}\n\nconst isRenderer = def => !!(def != null && def.render);\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\n\nfunction calculateDpr(dpr) {\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;\n}\n\nconst context = /*#__PURE__*/React.createContext(null);\n\nconst createStore = (applyProps, invalidate, advance, props) => {\n  const {\n    gl,\n    size,\n    shadows = false,\n    linear = false,\n    flat = false,\n    vr = false,\n    orthographic = false,\n    frameloop = 'always',\n    dpr = 1,\n    performance,\n    clock = new THREE.Clock(),\n    raycaster: raycastOptions,\n    camera: cameraOptions,\n    onPointerMissed\n  } = props; // Set shadowmap\n\n  if (shadows) {\n    gl.shadowMap.enabled = true;\n    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE.PCFSoftShadowMap;\n  } // Set color management\n\n\n  if (!linear) gl.outputEncoding = THREE.sRGBEncoding;\n  if (!flat) gl.toneMapping = THREE.ACESFilmicToneMapping; // clock.elapsedTime is updated using advance(timestamp)\n\n  if (frameloop === 'never') {\n    clock.stop();\n    clock.elapsedTime = 0;\n  }\n\n  const rootState = create((set, get) => {\n    // Create custom raycaster\n    const raycaster = new THREE.Raycaster();\n    const {\n      params,\n      ...options\n    } = raycastOptions || {};\n    applyProps(raycaster, {\n      enabled: true,\n      ...options,\n      params: { ...raycaster.params,\n        ...params\n      }\n    }); // Create default camera\n\n    const isCamera = cameraOptions instanceof THREE.Camera;\n    const camera = isCamera ? cameraOptions : orthographic ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE.PerspectiveCamera(75, 0, 0.1, 1000);\n\n    if (!isCamera) {\n      camera.position.z = 5;\n      if (cameraOptions) applyProps(camera, cameraOptions); // Always look at center by default\n\n      if (!(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n    }\n\n    const initialDpr = calculateDpr(dpr);\n    const position = new THREE.Vector3();\n    const defaultTarget = new THREE.Vector3();\n    const tempTarget = new THREE.Vector3();\n\n    function getCurrentViewport() {\n      let camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : get().camera;\n      let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTarget;\n      let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : get().size;\n      const {\n        width,\n        height\n      } = size;\n      const aspect = width / height;\n      if (target instanceof THREE.Vector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n\n    let performanceTimeout = undefined;\n\n    const setPerformanceCurrent = current => set(state => ({\n      performance: { ...state.performance,\n        current\n      }\n    }));\n\n    return {\n      gl,\n      set,\n      get,\n      invalidate: () => invalidate(get()),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      linear,\n      flat,\n      scene: prepare(new THREE.Scene()),\n      camera,\n      controls: null,\n      raycaster,\n      clock,\n      mouse: new THREE.Vector2(),\n      vr,\n      frameloop,\n      onPointerMissed,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        ...performance,\n        regress: () => {\n          const state = get(); // Clear timeout\n\n          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance\n\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile\n\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0\n      },\n      viewport: {\n        initialDpr,\n        dpr: initialDpr,\n        width: 0,\n        height: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setSize: (width, height) => {\n        const size = {\n          width,\n          height\n        };\n        set(state => ({\n          size,\n          viewport: { ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => ({\n        viewport: { ...state.viewport,\n          dpr: calculateDpr(dpr)\n        }\n      })),\n      events: {\n        connected: false\n      },\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastProps: props,\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: function (ref) {\n          let priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          set(_ref7 => {\n            let {\n              internal\n            } = _ref7;\n            return {\n              internal: { ...internal,\n                // If this subscription was given a priority, it takes rendering into its own hands\n                // For that reason we switch off automatic rendering and increase the manual flag\n                // As long as this flag is positive there can be no internal rendering at all\n                // because there could be multiple render subscriptions\n                priority: internal.priority + (priority > 0 ? 1 : 0),\n                // Register subscriber and sort layers from lowest to highest, meaning,\n                // highest priority renders last (on top of the other frames)\n                subscribers: [...internal.subscribers, {\n                  ref,\n                  priority\n                }].sort((a, b) => a.priority - b.priority)\n              }\n            };\n          });\n          return () => {\n            set(_ref8 => {\n              let {\n                internal\n              } = _ref8;\n              return {\n                internal: { ...internal,\n                  // Decrease manual flag if this subscription had a priority\n                  priority: internal.priority - (priority > 0 ? 1 : 0),\n                  // Remove subscriber from list\n                  subscribers: internal.subscribers.filter(s => s.ref !== ref)\n                }\n              };\n            });\n          };\n        }\n      }\n    };\n  }); // Resize camera and renderer on changes to size and pixelratio\n\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      internal\n    } = rootState.getState(); // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n\n    if (!(internal.lastProps.camera instanceof THREE.Camera)) {\n      if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n      } else {\n        camera.aspect = size.width / size.height;\n      }\n\n      camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178\n      // Update matrix world since the renderer is a frame late\n\n      camera.updateMatrixWorld();\n    } // Update renderer\n\n\n    gl.setPixelRatio(viewport.dpr);\n    gl.setSize(size.width, size.height);\n  }, state => [state.viewport.dpr, state.size], shallow);\n  const state = rootState.getState(); // Update size\n\n  if (size) state.setSize(size.width, size.height); // Invalidate on any change\n\n  rootState.subscribe(state => invalidate(state)); // Return root state\n\n  return rootState;\n};\n\nfunction createSubs(callback, subs) {\n  const index = subs.length;\n  subs.push(callback);\n  return () => void subs.splice(index, 1);\n}\n\nlet i;\nlet globalEffects = [];\nlet globalAfterEffects = [];\nlet globalTailEffects = [];\n\nconst addEffect = callback => createSubs(callback, globalEffects);\n\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\n\nconst addTail = callback => createSubs(callback, globalTailEffects);\n\nfunction run(effects, timestamp) {\n  for (i = 0; i < effects.length; i++) effects[i](timestamp);\n}\n\nfunction render$1(timestamp, state) {\n  // Run local effects\n  let delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp\n\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  } // Call subscribers (useFrame)\n\n\n  for (i = 0; i < state.internal.subscribers.length; i++) state.internal.subscribers[i].ref.current(state, delta); // Render content\n\n\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count\n\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\n\nfunction createLoop(roots) {\n  let running = false;\n  let repeat;\n\n  function loop(timestamp) {\n    running = true;\n    repeat = 0; // Run effects\n\n    run(globalEffects, timestamp); // Render all roots\n\n    roots.forEach(root => {\n      const state = root.store.getState(); // If the frameloop is invalidated, do not run another frame\n\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);\n    }); // Run after-effects\n\n    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop\n\n    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops\n    else run(globalTailEffects, timestamp); // Flag end of operation\n\n    running = false;\n  }\n\n  function invalidate(state) {\n    if (!state) return roots.forEach(root => invalidate(root.store.getState()));\n    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60\n\n    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it\n\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n\n  function advance(timestamp) {\n    let runGlobalEffects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let state = arguments.length > 2 ? arguments[2] : undefined;\n    if (runGlobalEffects) run(globalEffects, timestamp);\n    if (!state) roots.forEach(root => render$1(timestamp, root.store.getState()));else render$1(timestamp, state);\n    if (runGlobalEffects) run(globalAfterEffects, timestamp);\n  }\n\n  return {\n    loop,\n    invalidate,\n    advance\n  };\n}\n\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  const names = {\n    onClick: ['click', false],\n    onContextMenu: ['contextmenu', false],\n    onDoubleClick: ['dblclick', false],\n    onWheel: ['wheel', true],\n    onPointerDown: ['pointerdown', true],\n    onPointerUp: ['pointerup', true],\n    onPointerLeave: ['pointerleave', true],\n    onPointerMove: ['pointermove', true],\n    onPointerCancel: ['pointercancel', true],\n    onLostPointerCapture: ['lostpointercapture', true]\n  };\n  return {\n    connected: false,\n    handlers: Object.keys(names).reduce((acc, key) => ({ ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    connect: target => {\n      var _events$handlers;\n\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: { ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(_ref9 => {\n        let [name, event] = _ref9;\n        const [eventName, passive] = names[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n\n      if (events.connected) {\n        var _events$handlers2;\n\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(_ref10 => {\n          let [name, event] = _ref10;\n\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = names[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: { ...state.events,\n            connected: false\n          }\n        }));\n      }\n    }\n  };\n} // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction Block(_ref11) {\n  let {\n    set\n  } = _ref11;\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, []);\n  return null;\n}\n\nclass ErrorBoundary extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      error: false\n    };\n  }\n\n  componentDidCatch(error) {\n    this.props.set(error);\n  }\n\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n\n}\n\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\n\nconst Canvas = /*#__PURE__*/React.forwardRef(function Canvas(_ref12, forwardedRef) {\n  let {\n    children,\n    fallback,\n    tabIndex,\n    resize,\n    id,\n    style,\n    className,\n    events,\n    ...props\n  } = _ref12;\n  const [containerRef, {\n    width,\n    height\n  }] = useMeasure({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = React.useRef(null);\n  const [block, setBlock] = React.useState(false);\n  const [error, setError] = React.useState(false); // Suspend this component if block is a promise (2nd run)\n\n  if (block) throw block; // Throw exception outwards if anything within canvas throws\n\n  if (error) throw error; // Execute JSX in the reconciler as a layout-effect\n\n  useIsomorphicLayoutEffect(() => {\n    if (width > 0 && height > 0) {\n      render( /*#__PURE__*/React.createElement(ErrorBoundary, {\n        set: setError\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: /*#__PURE__*/React.createElement(Block, {\n          set: setBlock\n        })\n      }, children)), canvasRef.current, { ...props,\n        size: {\n          width,\n          height\n        },\n        events: events || createPointerEvents\n      });\n    }\n  }, [width, height, children]);\n  useIsomorphicLayoutEffect(() => {\n    const container = canvasRef.current;\n    return () => unmountComponentAtNode(container);\n  }, []);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    id: id,\n    className: className,\n    tabIndex: tabIndex,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      ...style\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: mergeRefs([canvasRef, forwardedRef]),\n    style: {\n      display: 'block'\n    }\n  }, fallback));\n});\n\nfunction useStore() {\n  const store = React.useContext(context);\n  if (!store) throw `R3F hooks can only be used within the Canvas component!`;\n  return store;\n}\n\nfunction useThree() {\n  let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : state => state;\n  let equalityFn = arguments.length > 1 ? arguments[1] : undefined;\n  return useStore()(selector, equalityFn);\n}\n\nfunction useFrame(callback) {\n  let renderPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const subscribe = useStore().getState().internal.subscribe; // Update ref\n\n  const ref = React.useRef(callback);\n  React.useLayoutEffect(() => void (ref.current = callback), [callback]); // Subscribe on mount, unsubscribe on unmount\n\n  React.useLayoutEffect(() => subscribe(ref, renderPriority), [renderPriority, subscribe]);\n  return null;\n}\n\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) {\n        data.nodes[obj.name] = obj;\n      }\n\n      if (obj.material && !data.materials[obj.material.name]) {\n        data.materials[obj.material.name] = obj.material;\n      }\n    });\n  }\n\n  return data;\n}\n\nfunction useGraph(object) {\n  return React.useMemo(() => buildGraph(object), [object]);\n}\n\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto) {\n    // Construct new loader and run extensions\n    const loader = new Proto();\n    if (extensions) extensions(loader); // Go through the urls and load them\n\n    for (var _len = arguments.length, input = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      input[_key - 1] = arguments[_key];\n    }\n\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(`Could not load ${input}: ${error.message}`)))));\n  };\n}\n\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = useAsset(loadingFn(extensions, onProgress), Proto, ...keys); // Return the object/s\n\n  return Array.isArray(input) ? results : results[0];\n}\n\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.preload(loadingFn(extensions), Proto, ...keys);\n};\n\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.clear(Proto, ...keys);\n};\n\nconst roots = new Map();\nconst modes = ['legacy', 'blocking', 'concurrent'];\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer();\n\nconst createRendererInstance = (gl, canvas) => {\n  const customRenderer = typeof gl === 'function' ? gl(canvas) : gl;\n  if (isRenderer(customRenderer)) return customRenderer;\n  const renderer = new THREE.WebGLRenderer({\n    powerPreference: 'high-performance',\n    canvas: canvas,\n    antialias: true,\n    alpha: true,\n    ...gl\n  });\n  if (gl) applyProps(renderer, gl);\n  return renderer;\n};\n\nfunction render(element, canvas) {\n  let {\n    gl,\n    size,\n    mode = modes[1],\n    events,\n    onCreated,\n    ...props\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _store; // Allow size to take on container bounds initially\n\n\n  if (!size) {\n    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;\n\n    size = {\n      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,\n      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0\n    };\n  }\n\n  let root = roots.get(canvas);\n  let fiber = root == null ? void 0 : root.fiber;\n  let store = root == null ? void 0 : root.store;\n  let state = (_store = store) == null ? void 0 : _store.getState();\n\n  if (fiber && state) {\n    // When a root was found, see if any fundamental props must be changed or exchanged\n    // Check pixelratio\n    if (props.dpr !== undefined && !is.equ(state.viewport.dpr, calculateDpr(props.dpr))) state.setDpr(props.dpr); // Check size\n\n    if (state.size.width !== size.width || state.size.height !== size.height) state.setSize(size.width, size.height); // For some props we want to reset the entire root\n    // Changes to the color-space\n\n    const linearChanged = props.linear !== state.internal.lastProps.linear;\n\n    if (linearChanged) {\n      unmountComponentAtNode(canvas);\n      fiber = undefined;\n    }\n  }\n\n  if (!fiber) {\n    // If no root has been found, make one\n    // Create gl\n    const glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested\n\n    if (props.vr) {\n      glRenderer.xr.enabled = true;\n      glRenderer.setAnimationLoop(timestamp => advance(timestamp, true));\n    } // Create store\n\n\n    store = createStore(applyProps, invalidate, advance, {\n      gl: glRenderer,\n      size,\n      ...props\n    });\n    const state = store.getState(); // Create renderer\n\n    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it\n\n    roots.set(canvas, {\n      fiber,\n      store\n    }); // Store events internally\n\n    if (events) state.set({\n      events: events(store)\n    });\n  }\n\n  if (store && fiber) {\n    reconciler.updateContainer( /*#__PURE__*/React.createElement(Provider, {\n      store: store,\n      element: element,\n      onCreated: onCreated,\n      target: canvas\n    }), fiber, null, () => undefined);\n    return store;\n  } else {\n    throw 'Error creating root!';\n  }\n}\n\nfunction Provider(_ref13) {\n  let {\n    store,\n    element,\n    onCreated,\n    target\n  } = _ref13;\n  React.useEffect(() => {\n    const state = store.getState(); // Flag the canvas active, rendering will now begin\n\n    state.set(state => ({\n      internal: { ...state.internal,\n        active: true\n      }\n    })); // Connect events\n\n    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n\n    if (onCreated) onCreated(state);\n  }, []);\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: store\n  }, element);\n}\n\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          var _state$gl, _state$gl$renderLists, _state$gl2;\n\n          state.events.disconnect == null ? void 0 : state.events.disconnect();\n          (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n          (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n          dispose(state);\n          roots.delete(canvas);\n          if (callback) callback(canvas);\n        }, 500);\n      }\n    });\n  }\n}\n\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n\n  for (const p in obj) {\n    var _dispose, _ref;\n\n    (_dispose = (_ref = p).dispose) == null ? void 0 : _dispose.call(_ref);\n    delete obj[p];\n  }\n}\n\nconst act = reconciler.act;\n\nfunction createPortal(children, container) {\n  return reconciler.createPortal(children, container, null, null);\n}\n\nreconciler.injectIntoDevTools({\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: '17.0.2'\n});\nexport { Canvas, threeTypes as ReactThreeFiber, roots as _roots, act, addAfterEffect, addEffect, addTail, advance, applyProps, context, createPortal, dispose, createPointerEvents as events, extend, invalidate, reconciler, render, unmountComponentAtNode, useFrame, useGraph, useLoader, useStore, useThree };","map":{"version":3,"names":["THREE","React","create","shallow","Reconciler","unstable_now","unstable_runWithPriority","unstable_IdlePriority","useAsset","mergeRefs","useMeasure","threeTypes","Object","freeze","__proto__","is","obj","a","arr","fun","str","num","und","Array","isArray","equ","b","i","makeId","event","eventObject","object","uuid","index","instanceId","removeInteractivity","store","internal","getState","interaction","filter","o","initialHits","hovered","forEach","value","key","delete","createEvents","temp","Vector3","prepareRay","_raycaster$computeOff","state","raycaster","mouse","camera","size","offsetX","offsetY","computeOffsets","width","height","set","setFromCamera","calculateDistance","dx","initialClick","dy","Math","round","sqrt","filterPointerEvents","objects","some","name","_r3f","__r3f","handlers","intersect","enabled","seen","Set","intersections","eventsObjects","intersects","intersectObjects","item","id","has","add","_r3f2","count","push","parent","patchIntersects","capturedMap","pointerId","get","values","handleIntersects","delta","callback","length","unprojectedPoint","x","y","unproject","releasePointerCapture","target","localState","stopped","hit","hasPointerCapture","_internal$capturedMap","_internal$capturedMap2","setPointerCapture","Map","extractEventProps","prop","getPrototypeOf","property","raycastEvent","spaceX","spaceY","ray","stopPropagation","capturesForPointer","from","find","higher","slice","indexOf","cancelPointer","currentTarget","sourceEvent","nativeEvent","hits","hoveredObj","_r3f3","data","onPointerOut","onPointerLeave","handlePointer","onPointerMissed","isPointerMove","isClickEvent","undefined","map","pointerMissed","_r3f4","onPointerOver","onPointerEnter","hoveredItem","onPointerMove","handler","includes","_r3f5","isDiffSet","def","memoized","changes","isStore","getContainer","container","child","_container$__r3f$root","_container$__r3f","root","scene","DEFAULT","EMPTY","catalogue","extend","checkShallow","prepare","instance","primitive","memoizedProps","createRenderer","roots","diffProps","children","cN","kN","ref","rN","props","cP","kP","rP","previous","accumulative","_instance$__r3f","entries","previousKeys","keys","hasOwnProperty","unshift","_instance$__r3f2","test","split","args","attach","applyProps","_instance$__r3f3","_root$getState","_localState$handlers","_localState$handlers2","_instance$__r3f4","rootState","prevHandlers","isEvent","currentInstance","targetProp","reduce","acc","reverseEntries","reverse","constructor","defaultClassCall","dispose","copy","Layers","fromArray","isColor","Color","setScalar","mask","linear","convertSRGBToLinear","Texture","encoding","sRGBEncoding","invalidateInstance","raycast","splice","updateInstance","_instance$__r3f5","_instance$__r3f5$root","frames","invalidate","onUpdate","createInstance","type","hostContext","internalInstanceHandle","toUpperCase","fn","node","return","stateNode","containerInfo","endsWith","appendChild","parentInstance","addedAsChild","attachArray","attachObject","attachFns","attachFn","isObject3D","insertBefore","beforeChild","added","array","dispatchEvent","restSiblings","sibling","removeRecursive","removeChild","_parentInstance$__r3f","_child$__r3f2","detachFn","_child$__r3f","remove","isPrimitive","shouldDispose","_child$__r3f3","e","switchInstance","newProps","fiber","_instance$__r3f6","newInstance","alternate","current","reconciler","now","appendInitialChild","warnsIfNotActing","supportsMutation","isPrimaryRenderer","scheduleTimeout","setTimeout","cancelTimeout","clearTimeout","noTimeout","appendChildToContainer","removeChildFromContainer","insertInContainerBefore","prepareUpdate","oldProps","argsNew","restNew","argsOld","cO","restOld","diff","commitUpdate","reconstruct","hideInstance","visible","unhideInstance","hideTextInstance","Error","getPublicInstance","getRootHostContext","rootContainer","getChildHostContext","parentHostContext","createTextInstance","finalizeInitialChildren","commitMount","shouldDeprioritizeSubtree","prepareForCommit","preparePortalMount","resetAfterCommit","shouldSetTextContent","clearContainer","isRenderer","render","isOrthographicCamera","calculateDpr","dpr","min","max","window","devicePixelRatio","context","createContext","createStore","advance","gl","shadows","flat","vr","orthographic","frameloop","performance","clock","Clock","raycastOptions","cameraOptions","shadowMap","assign","PCFSoftShadowMap","outputEncoding","toneMapping","ACESFilmicToneMapping","stop","elapsedTime","Raycaster","params","options","isCamera","Camera","OrthographicCamera","PerspectiveCamera","position","z","rotation","lookAt","initialDpr","defaultTarget","tempTarget","getCurrentViewport","aspect","distance","getWorldPosition","distanceTo","zoom","factor","fov","PI","h","tan","w","performanceTimeout","setPerformanceCurrent","timestamp","runGlobalEffects","Scene","controls","Vector2","debounce","regress","viewport","setSize","setDpr","events","connected","active","priority","lastProps","subscribers","subscribe","sort","s","left","right","top","bottom","updateProjectionMatrix","updateMatrixWorld","setPixelRatio","createSubs","subs","globalEffects","globalAfterEffects","globalTailEffects","addEffect","addAfterEffect","addTail","run","effects","render$1","getDelta","oldTime","createLoop","running","repeat","loop","requestAnimationFrame","createPointerEvents","names","onClick","onContextMenu","onDoubleClick","onWheel","onPointerDown","onPointerUp","onPointerCancel","onLostPointerCapture","connect","_events$handlers","disconnect","eventName","passive","addEventListener","_events$handlers2","HTMLElement","removeEventListener","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","Block","Promise","ErrorBoundary","Component","error","componentDidCatch","getDerivedStateFromError","Canvas","forwardRef","forwardedRef","fallback","tabIndex","resize","style","className","containerRef","scroll","canvasRef","useRef","block","setBlock","useState","setError","createElement","Suspense","unmountComponentAtNode","overflow","display","useStore","useContext","useThree","selector","equalityFn","useFrame","renderPriority","buildGraph","nodes","materials","traverse","material","useGraph","useMemo","loadingFn","extensions","onProgress","Proto","loader","input","all","res","reject","load","message","useLoader","results","preload","clear","modes","createRendererInstance","canvas","customRenderer","renderer","WebGLRenderer","powerPreference","antialias","alpha","element","mode","onCreated","_store","_canvas$parentElement","_canvas$parentElement2","_canvas$parentElement3","_canvas$parentElement4","parentElement","clientWidth","clientHeight","linearChanged","glRenderer","xr","setAnimationLoop","createContainer","updateContainer","Provider","_state$gl","_state$gl$renderLists","_state$gl2","renderLists","forceContextLoss","p","_dispose","_ref","call","act","createPortal","injectIntoDevTools","bundleType","process","env","NODE_ENV","rendererPackageName","version","ReactThreeFiber","_roots"],"sources":["/Users/khuong/Desktop/ReactJS/the-three-graces/node_modules/@react-three/fiber/dist/react-three-fiber.esm.js"],"sourcesContent":["import * as THREE from 'three';\nimport * as React from 'react';\nimport create from 'zustand';\nimport shallow from 'zustand/shallow';\nimport Reconciler from 'react-reconciler';\nimport { unstable_now, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';\nimport { useAsset } from 'use-asset';\nimport mergeRefs from 'react-merge-refs';\nimport useMeasure from 'react-use-measure';\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n\n  equ(a, b) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    let i;\n\n    for (i in a) if (!(i in b)) return false;\n\n    for (i in b) if (a[i] !== b[i]) return false;\n\n    return is.und(i) ? a === b : true;\n  }\n\n};\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState(); // Removes every trace of an object from the data store\n\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      internal.hovered.delete(key);\n    }\n  });\n}\nfunction createEvents(store) {\n  const temp = new THREE.Vector3();\n  /** Sets up defaultRaycaster */\n\n  function prepareRay(event) {\n    var _raycaster$computeOff;\n\n    const state = store.getState();\n    const {\n      raycaster,\n      mouse,\n      camera,\n      size\n    } = state; // https://github.com/pmndrs/react-three-fiber/pull/782\n    // Events trigger outside of canvas when moved\n\n    const {\n      offsetX,\n      offsetY\n    } = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event;\n    const {\n      width,\n      height\n    } = size;\n    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\n    raycaster.setFromCamera(mouse, camera);\n  }\n  /** Calculates delta */\n\n\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n\n\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n\n  function intersect(filter) {\n    const state = store.getState();\n    const {\n      raycaster,\n      internal\n    } = state; // Skip event handling when noEvents is set\n\n    if (!raycaster.enabled) return [];\n    const seen = new Set();\n    const intersections = []; // Allow callers to eliminate event objects\n\n    const eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates\n\n    let intersects = raycaster.intersectObjects(eventsObjects, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    }); // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order\n\n    if (raycaster.filter) intersects = raycaster.filter(intersects, state);\n\n    for (const intersect of intersects) {\n      let eventObject = intersect.object; // Bubble event up\n\n      while (eventObject) {\n        var _r3f2;\n\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.handlers.count) intersections.push({ ...intersect,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    return intersections;\n  }\n  /**  Creates filtered intersects and returns an array of positive hits */\n\n\n  function patchIntersects(intersections, event) {\n    const {\n      internal\n    } = store.getState(); // If the interaction is captured, make all capturing targets  part of the\n    // intersect.\n\n    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n      intersections.push(...internal.capturedMap.get(event.pointerId).values());\n    }\n\n    return intersections;\n  }\n  /**  Handles intersections by forwarding them to handlers */\n\n\n  function handleIntersects(intersections, event, delta, callback) {\n    const {\n      raycaster,\n      mouse,\n      camera,\n      internal\n    } = store.getState(); // If anything has been found, forward it to the event listeners\n\n    if (intersections.length) {\n      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);\n\n      const releasePointerCapture = id => event.target.releasePointerCapture(id);\n\n      const localState = {\n        stopped: false\n      };\n\n      for (const hit of intersections) {\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n\n        const setPointerCapture = id => {\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, hit);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));\n          } // Call the original event now\n          event.target.setPointerCapture(id);\n        }; // Add native event props\n\n\n        let extractEventProps = {};\n\n        for (let prop in Object.getPrototypeOf(event)) {\n          let property = event[prop]; // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n\n        let raycastEvent = { ...hit,\n          ...extractEventProps,\n          spaceX: mouse.x,\n          spaceY: mouse.y,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...\n\n            if ( // ...if this pointer hasn't been captured\n            !capturesForPointer || // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          sourceEvent: event,\n          // deprecated\n          nativeEvent: event\n        }; // Call subscribers\n\n        callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation\n\n        if (localState.stopped === true) break;\n      }\n    }\n\n    return intersections;\n  }\n\n  function cancelPointer(hits) {\n    const {\n      internal\n    } = store.getState();\n    Array.from(internal.hovered.values()).forEach(hoveredObj => {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!hits.length || !hits.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        var _r3f3;\n\n        const eventObject = hoveredObj.eventObject;\n        const handlers = (_r3f3 = eventObject.__r3f) == null ? void 0 : _r3f3.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n\n        if (handlers != null && handlers.count) {\n          // Clear out intersects, they are outdated by now\n          const data = { ...hoveredObj,\n            intersections: hits || []\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    });\n  }\n\n  const handlePointer = name => {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n\n      case 'onLostPointerCapture':\n        return event => {\n          if ('pointerId' in event) {\n            // this will be a problem if one target releases the pointerId\n            // and another one is still keeping it, as the line below\n            // indifferently deletes all capturing references.\n            store.getState().internal.capturedMap.delete(event.pointerId);\n          }\n\n          cancelPointer([]);\n        };\n    } // Any other pointer goes here ...\n\n\n    return event => {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n      prepareRay(event); // Get fresh intersects\n\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = patchIntersects(intersect(filter), event);\n      const delta = isClickEvent ? calculateDistance(event) : 0; // Save initial coordinates on pointer-down\n\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      } // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n\n\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      } // Take care of unhover\n\n\n      if (isPointerMove) cancelPointer(hits);\n      handleIntersects(hits, event, delta, data => {\n        var _r3f4;\n\n        const eventObject = data.eventObject;\n        const handlers = (_r3f4 = eventObject.__r3f) == null ? void 0 : _r3f4.handlers; // Check presence of handlers\n\n        if (!(handlers != null && handlers.count)) return;\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          } // Call mouse move\n\n\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (name !== 'onClick' && name !== 'onContextMenu' && name !== 'onDoubleClick' || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object))); // Now call the handler\n\n              handler(data);\n            }\n          }\n        }\n      });\n    };\n  };\n\n  function pointerMissed(event, objects) {\n    objects.forEach(object => {\n      var _r3f5;\n\n      return (_r3f5 = object.__r3f) == null ? void 0 : _r3f5.handlers.onPointerMissed == null ? void 0 : _r3f5.handlers.onPointerMissed(event);\n    });\n  }\n\n  return {\n    handlePointer\n  };\n}\n\nconst isDiffSet = def => def && !!def.memoized && !!def.changes;\n\n// Type guard to tell a store from a portal\nconst isStore = def => def && !!def.getState;\n\nconst getContainer = (container, child) => {\n  var _container$__r3f$root, _container$__r3f;\n\n  return {\n    // If the container is not a root-store then it must be a THREE.Object3D into which part of the\n    // scene is portalled into. Now there can be two variants of this, either that object is part of\n    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies\n    // outside react, in which case we must take the root of the child that is about to be attached to it.\n    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,\n    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D\n    container: isStore(container) ? container.getState().scene : container\n  };\n};\n\nconst DEFAULT = '__default';\nconst EMPTY = {};\nlet catalogue = {};\n\nlet extend = objects => void (catalogue = { ...catalogue,\n  ...objects\n}); // Shallow check arrays, but check objects atomically\n\n\nfunction checkShallow(a, b) {\n  if (is.arr(a) && is.equ(a, b)) return true;\n  if (a === b) return true;\n  return false;\n} // Each object in the scene carries a small LocalState descriptor\n\n\nfunction prepare(object, state) {\n  const instance = object;\n\n  if (state != null && state.primitive || !instance.__r3f) {\n    instance.__r3f = {\n      root: null,\n      memoizedProps: {},\n      handlers: {\n        count: 0\n      },\n      objects: [],\n      parent: null,\n      ...state\n    };\n  }\n\n  return object;\n}\n\nfunction createRenderer(roots) {\n  // This function prepares a set of changes to be applied to the instance\n  function diffProps(instance, {\n    children: cN,\n    key: kN,\n    ref: rN,\n    ...props\n  }, {\n    children: cP,\n    key: kP,\n    ref: rP,\n    ...previous\n  } = {}, accumulative = false) {\n    var _instance$__r3f;\n\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = []; // Catch removed props, prepend them so they can be reset or removed\n\n    if (accumulative) {\n      const previousKeys = Object.keys(previous);\n\n      for (let i = 0; i < previousKeys.length; i++) if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([previousKeys[i], DEFAULT + 'remove']);\n    }\n\n    entries.forEach(([key, value]) => {\n      var _instance$__r3f2;\n\n      // Bail out on primitive object\n      if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === 'object') return; // When props match bail out\n\n      if (checkShallow(value, previous[key])) return; // Collect handlers and bail out\n\n      if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([key, value, true, []]); // Split dashed props\n\n      let entries = [];\n      if (key.includes('-')) entries = key.split('-');\n      changes.push([key, value, false, entries]);\n    });\n    const memoized = { ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n      accumulative,\n      memoized,\n      changes\n    };\n  }\n\n  function applyProps(instance, data) {\n    var _instance$__r3f3, _root$getState, _localState$handlers, _localState$handlers2, _instance$__r3f4;\n\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const {\n      memoized,\n      changes\n    } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = (_localState$handlers = localState.handlers) == null ? void 0 : _localState$handlers.count; // Prepare memoized props\n\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    changes.forEach(([key, value, isEvent, keys]) => {\n      let currentInstance = instance;\n      let targetProp = currentInstance[key]; // Revolve dashed props\n\n      if (keys.length) {\n        targetProp = keys.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\n\n        if (!(targetProp && targetProp.set)) {\n          const [name, ...reverseEntries] = keys.reverse();\n          currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n          key = name;\n        }\n      } // https://github.com/mrdoob/three.js/issues/21209\n      // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n      // has no means to do this. Hence we curate a small collection of value-classes\n      // with their respective constructor/set arguments\n      // For removed props, try to set default values, if possible\n\n\n      if (value === DEFAULT + 'remove') {\n        if (targetProp && targetProp.constructor) {\n          // use the prop constructor to find the default it should be\n          value = new targetProp.constructor(memoized.args);\n        } else if (currentInstance.constructor) {\n          // create a blank slate of the instance and copy the particular parameter.\n          // @ts-ignore\n          const defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);\n          value = defaultClassCall[targetProp]; // destory the instance\n\n          if (defaultClassCall.dispose) defaultClassCall.dispose(); // instance does not have constructor, just set it to 0\n        } else value = 0;\n      } // Deal with pointer events ...\n\n\n      if (isEvent) {\n        if (value) localState.handlers[key] = value;else delete localState.handlers[key];\n        localState.handlers.count = Object.keys(localState.handlers).length;\n      } // Special treatment for objects with support for set/copy, and layers\n      else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE.Layers)) {\n          // If value is an array\n          if (Array.isArray(value)) {\n            if (targetProp.fromArray) targetProp.fromArray(value);else targetProp.set(...value);\n          } // Test again target.copy(class) next ...\n          else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) targetProp.copy(value); // If nothing else fits, just set the single value, ignore undefined\n            // https://github.com/react-spring/react-three-fiber/issues/274\n            else if (value !== undefined) {\n                const isColor = targetProp instanceof THREE.Color; // Allow setting array scalars\n\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property\n                else if (targetProp instanceof THREE.Layers && value instanceof THREE.Layers) targetProp.mask = value.mask; // Otherwise just set ...\n                  else targetProp.set(value); // Auto-convert sRGB colors, for now ...\n                // https://github.com/react-spring/react-three-fiber/issues/344\n\n                if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();\n              } // Else, just overwrite the value\n\n        } else {\n          currentInstance[key] = value; // Auto-convert sRGB textures, for now ...\n          // https://github.com/react-spring/react-three-fiber/issues/344\n\n          if (!rootState.linear && currentInstance[key] instanceof THREE.Texture) currentInstance[key].encoding = THREE.sRGBEncoding;\n        }\n\n      invalidateInstance(instance);\n    });\n\n    if (rootState.internal && instance.raycast && prevHandlers !== ((_localState$handlers2 = localState.handlers) == null ? void 0 : _localState$handlers2.count)) {\n      // Pre-emptively remove the instance from the interaction manager\n      const index = rootState.internal.interaction.indexOf(instance);\n      if (index > -1) rootState.internal.interaction.splice(index, 1); // Add the instance to the interaction manager only when it has handlers\n\n      if (localState.handlers.count) rootState.internal.interaction.push(instance);\n    } // Call the update lifecycle when it is being updated\n\n\n    if (changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n  }\n\n  function invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n  }\n\n  function updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n  }\n\n  function createInstance(type, {\n    args = [],\n    ...props\n  }, root, hostContext, internalInstanceHandle) {\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance; // https://github.com/facebook/react/issues/17147\n    // Portals do not give us a root, they are themselves treated as a root by the reconciler\n    // In order to figure out the actual root we have to climb through fiber internals :(\n\n    if (!isStore(root) && internalInstanceHandle) {\n      const fn = node => {\n        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);\n      };\n\n      root = fn(internalInstanceHandle);\n    } // Assert that by now we have a valid root\n\n\n    if (!root || !isStore(root)) throw `No valid root for ${name}!`;\n\n    if (type === 'primitive') {\n      if (props.object === undefined) throw `Primitives without 'object' are invalid!`;\n      const object = props.object;\n      instance = prepare(object, {\n        root,\n        primitive: true\n      });\n    } else {\n      const target = catalogue[name] || THREE[name];\n      if (!target) throw `${name} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`; // Instanciate new object, link it to the root\n      // Append memoized props with args so it's not forgotten\n\n      instance = prepare(new target(...args), {\n        root,\n        memoizedProps: {\n          args: args.length === 0 ? null : args\n        }\n      });\n    } // Auto-attach geometries and materials\n\n\n    if (!('attachFns' in props)) {\n      if (name.endsWith('Geometry')) {\n        props = {\n          attach: 'geometry',\n          ...props\n        };\n      } else if (name.endsWith('Material')) {\n        props = {\n          attach: 'material',\n          ...props\n        };\n      }\n    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n\n\n    applyProps(instance, props);\n    return instance;\n  }\n\n  function appendChild(parentInstance, child) {\n    let addedAsChild = false;\n\n    if (child) {\n      // The attach attribute implies that the object attaches itself on the parent\n      if (child.attachArray) {\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n        parentInstance[child.attachArray].push(child);\n      } else if (child.attachObject) {\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = child;\n      } else if (is.arr(child.attachFns)) {\n        const [attachFn] = child.attachFns;\n\n        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {\n          parentInstance[attachFn](child);\n        } else if (is.fun(attachFn)) {\n          attachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        addedAsChild = true;\n      }\n\n      if (!addedAsChild) {\n        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n        // that is, anything that's a child in React but not a child in the scenegraph.\n        parentInstance.__r3f.objects.push(child);\n      }\n\n      if (!child.__r3f) {\n        prepare(child, {});\n      }\n\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n\n    if (child) {\n      if (child.attachArray) {\n        const array = parentInstance[child.attachArray];\n        if (!is.arr(array)) parentInstance[child.attachArray] = [];\n        array.splice(array.indexOf(beforeChild), 0, child);\n      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {\n        // attach and attachObject don't have an order anyway, so just append\n        return appendChild(parentInstance, child);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n\n      if (!added) {\n        parentInstance.__r3f.objects.push(child);\n      }\n\n      if (!child.__r3f) {\n        prepare(child, {});\n      }\n\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function removeRecursive(array, parent, dispose = false) {\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _parentInstance$__r3f, _child$__r3f2;\n\n      if (child.__r3f) {\n        child.__r3f.parent = null;\n      }\n\n      if ((_parentInstance$__r3f = parentInstance.__r3f) != null && _parentInstance$__r3f.objects) {\n        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n      } // Remove attachment\n\n\n      if (child.attachArray) {\n        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);\n      } else if (child.attachObject) {\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = null;\n      } else if (is.arr(child.attachFns)) {\n        const [, detachFn] = child.attachFns;\n\n        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {\n          parentInstance[detachFn](child);\n        } else if (is.fun(detachFn)) {\n          detachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        var _child$__r3f;\n\n        parentInstance.remove(child); // Remove interactivity\n\n        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {\n          removeInteractivity(child.__r3f.root, child);\n        }\n      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be a <primitive object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n\n\n      const isPrimitive = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.primitive;\n      const shouldDispose = dispose === undefined ? child.dispose !== null && !isPrimitive : dispose; // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n\n      if (!isPrimitive) {\n        var _child$__r3f3;\n\n        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      } // Remove references\n\n\n      if (child.__r3f) {\n        delete child.__r3f.root;\n        delete child.__r3f.objects;\n        delete child.__r3f.handlers;\n        delete child.__r3f.memoizedProps;\n        if (!isPrimitive) delete child.__r3f;\n      } // Dispose item whenever the reconciler feels like it\n\n\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        unstable_runWithPriority(unstable_IdlePriority, () => {\n          try {\n            child.dispose();\n          } catch (e) {\n            /* ... */\n          }\n        });\n      }\n\n      invalidateInstance(parentInstance);\n    }\n  }\n\n  function switchInstance(instance, type, newProps, fiber) {\n    var _instance$__r3f6;\n\n    const parent = (_instance$__r3f6 = instance.__r3f) == null ? void 0 : _instance$__r3f6.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n    // This can not include primitives, which should not have declarative children\n\n    if (type !== 'primitive' && instance.children) {\n      instance.children.forEach(child => appendChild(newInstance, child));\n      instance.children = [];\n    }\n\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n\n    instance.__r3f.objects = [];\n    removeChild(parent, instance);\n    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n    // https://github.com/facebook/react/issues/14983\n    // https://github.com/facebook/react/pull/15021\n    ;\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n\n  const reconciler = Reconciler({\n    now: unstable_now,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    warnsIfNotActing: true,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    // @ts-ignore\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    // @ts-ignore\n    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    noTimeout: -1,\n    appendChildToContainer: (parentInstance, child) => {\n      const {\n        container,\n        root\n      } = getContainer(parentInstance, child); // Link current root to the default scene\n\n      container.__r3f.root = root;\n      appendChild(container, child);\n    },\n    removeChildFromContainer: (parentInstance, child) => removeChild(getContainer(parentInstance, child).container, child),\n    insertInContainerBefore: (parentInstance, child, beforeChild) => insertBefore(getContainer(parentInstance, child).container, child, beforeChild),\n\n    prepareUpdate(instance, type, oldProps, newProps) {\n      if (instance.__r3f.primitive && newProps.object && newProps.object !== instance) return [true];else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          children: cN,\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          children: cO,\n          ...restOld\n        } = oldProps; // If it has new props or arguments, then it needs to be re-instanciated\n\n        if (argsNew.some((value, index) => value !== argsOld[index])) return [true]; // Create a diff-set, flag if there are any changes\n\n        const diff = diffProps(instance, restNew, restOld, true);\n        if (diff.changes.length) return [false, diff]; // Otherwise do not touch the instance\n\n        return null;\n      }\n    },\n\n    commitUpdate(instance, [reconstruct, diff], type, oldProps, newProps, fiber) {\n      // Reconstruct when args or <primitive object={...} have changes\n      if (reconstruct) switchInstance(instance, type, newProps, fiber); // Otherwise just overwrite props\n      else applyProps(instance, diff);\n    },\n\n    hideInstance(instance) {\n      if (instance.isObject3D) {\n        instance.visible = false;\n        invalidateInstance(instance);\n      }\n    },\n\n    unhideInstance(instance, props) {\n      if (instance.isObject3D && props.visible == null || props.visible) {\n        instance.visible = true;\n        invalidateInstance(instance);\n      }\n    },\n\n    hideTextInstance() {\n      throw new Error('Text is not allowed in the R3F tree.');\n    },\n\n    getPublicInstance(instance) {\n      // TODO: might fix switchInstance (?)\n      return instance;\n    },\n\n    getRootHostContext(rootContainer) {\n      return EMPTY;\n    },\n\n    getChildHostContext(parentHostContext) {\n      return parentHostContext;\n    },\n\n    createTextInstance() {},\n\n    finalizeInitialChildren() {\n      return false;\n    },\n\n    commitMount() {// noop\n    },\n\n    shouldDeprioritizeSubtree() {\n      return false;\n    },\n\n    prepareForCommit() {\n      return null;\n    },\n\n    preparePortalMount(containerInfo) {\n      prepare(containerInfo);\n    },\n\n    resetAfterCommit() {// noop\n    },\n\n    shouldSetTextContent() {\n      return false;\n    },\n\n    clearContainer() {\n      return false;\n    }\n\n  });\n  return {\n    reconciler,\n    applyProps\n  };\n}\n\nconst isRenderer = def => !!(def != null && def.render);\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nfunction calculateDpr(dpr) {\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;\n}\nconst context = /*#__PURE__*/React.createContext(null);\n\nconst createStore = (applyProps, invalidate, advance, props) => {\n  const {\n    gl,\n    size,\n    shadows = false,\n    linear = false,\n    flat = false,\n    vr = false,\n    orthographic = false,\n    frameloop = 'always',\n    dpr = 1,\n    performance,\n    clock = new THREE.Clock(),\n    raycaster: raycastOptions,\n    camera: cameraOptions,\n    onPointerMissed\n  } = props; // Set shadowmap\n\n  if (shadows) {\n    gl.shadowMap.enabled = true;\n    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE.PCFSoftShadowMap;\n  } // Set color management\n\n\n  if (!linear) gl.outputEncoding = THREE.sRGBEncoding;\n  if (!flat) gl.toneMapping = THREE.ACESFilmicToneMapping; // clock.elapsedTime is updated using advance(timestamp)\n\n  if (frameloop === 'never') {\n    clock.stop();\n    clock.elapsedTime = 0;\n  }\n\n  const rootState = create((set, get) => {\n    // Create custom raycaster\n    const raycaster = new THREE.Raycaster();\n    const {\n      params,\n      ...options\n    } = raycastOptions || {};\n    applyProps(raycaster, {\n      enabled: true,\n      ...options,\n      params: { ...raycaster.params,\n        ...params\n      }\n    }); // Create default camera\n\n    const isCamera = cameraOptions instanceof THREE.Camera;\n    const camera = isCamera ? cameraOptions : orthographic ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE.PerspectiveCamera(75, 0, 0.1, 1000);\n\n    if (!isCamera) {\n      camera.position.z = 5;\n      if (cameraOptions) applyProps(camera, cameraOptions); // Always look at center by default\n\n      if (!(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n    }\n\n    const initialDpr = calculateDpr(dpr);\n    const position = new THREE.Vector3();\n    const defaultTarget = new THREE.Vector3();\n    const tempTarget = new THREE.Vector3();\n\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height\n      } = size;\n      const aspect = width / height;\n      if (target instanceof THREE.Vector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n\n    let performanceTimeout = undefined;\n\n    const setPerformanceCurrent = current => set(state => ({\n      performance: { ...state.performance,\n        current\n      }\n    }));\n\n    return {\n      gl,\n      set,\n      get,\n      invalidate: () => invalidate(get()),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      linear,\n      flat,\n      scene: prepare(new THREE.Scene()),\n      camera,\n      controls: null,\n      raycaster,\n      clock,\n      mouse: new THREE.Vector2(),\n      vr,\n      frameloop,\n      onPointerMissed,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        ...performance,\n        regress: () => {\n          const state = get(); // Clear timeout\n\n          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance\n\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile\n\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0\n      },\n      viewport: {\n        initialDpr,\n        dpr: initialDpr,\n        width: 0,\n        height: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setSize: (width, height) => {\n        const size = {\n          width,\n          height\n        };\n        set(state => ({\n          size,\n          viewport: { ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => ({\n        viewport: { ...state.viewport,\n          dpr: calculateDpr(dpr)\n        }\n      })),\n      events: {\n        connected: false\n      },\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastProps: props,\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: (ref, priority = 0) => {\n          set(({\n            internal\n          }) => ({\n            internal: { ...internal,\n              // If this subscription was given a priority, it takes rendering into its own hands\n              // For that reason we switch off automatic rendering and increase the manual flag\n              // As long as this flag is positive there can be no internal rendering at all\n              // because there could be multiple render subscriptions\n              priority: internal.priority + (priority > 0 ? 1 : 0),\n              // Register subscriber and sort layers from lowest to highest, meaning,\n              // highest priority renders last (on top of the other frames)\n              subscribers: [...internal.subscribers, {\n                ref,\n                priority\n              }].sort((a, b) => a.priority - b.priority)\n            }\n          }));\n          return () => {\n            set(({\n              internal\n            }) => ({\n              internal: { ...internal,\n                // Decrease manual flag if this subscription had a priority\n                priority: internal.priority - (priority > 0 ? 1 : 0),\n                // Remove subscriber from list\n                subscribers: internal.subscribers.filter(s => s.ref !== ref)\n              }\n            }));\n          };\n        }\n      }\n    };\n  }); // Resize camera and renderer on changes to size and pixelratio\n\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      internal\n    } = rootState.getState(); // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n\n    if (!(internal.lastProps.camera instanceof THREE.Camera)) {\n      if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n      } else {\n        camera.aspect = size.width / size.height;\n      }\n\n      camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178\n      // Update matrix world since the renderer is a frame late\n\n      camera.updateMatrixWorld();\n    } // Update renderer\n\n\n    gl.setPixelRatio(viewport.dpr);\n    gl.setSize(size.width, size.height);\n  }, state => [state.viewport.dpr, state.size], shallow);\n  const state = rootState.getState(); // Update size\n\n  if (size) state.setSize(size.width, size.height); // Invalidate on any change\n\n  rootState.subscribe(state => invalidate(state)); // Return root state\n\n  return rootState;\n};\n\nfunction createSubs(callback, subs) {\n  const index = subs.length;\n  subs.push(callback);\n  return () => void subs.splice(index, 1);\n}\n\nlet i;\nlet globalEffects = [];\nlet globalAfterEffects = [];\nlet globalTailEffects = [];\nconst addEffect = callback => createSubs(callback, globalEffects);\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\nconst addTail = callback => createSubs(callback, globalTailEffects);\n\nfunction run(effects, timestamp) {\n  for (i = 0; i < effects.length; i++) effects[i](timestamp);\n}\n\nfunction render$1(timestamp, state) {\n  // Run local effects\n  let delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp\n\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  } // Call subscribers (useFrame)\n\n\n  for (i = 0; i < state.internal.subscribers.length; i++) state.internal.subscribers[i].ref.current(state, delta); // Render content\n\n\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count\n\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\n\nfunction createLoop(roots) {\n  let running = false;\n  let repeat;\n\n  function loop(timestamp) {\n    running = true;\n    repeat = 0; // Run effects\n\n    run(globalEffects, timestamp); // Render all roots\n\n    roots.forEach(root => {\n      const state = root.store.getState(); // If the frameloop is invalidated, do not run another frame\n\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);\n    }); // Run after-effects\n\n    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop\n\n    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops\n    else run(globalTailEffects, timestamp); // Flag end of operation\n\n    running = false;\n  }\n\n  function invalidate(state) {\n    if (!state) return roots.forEach(root => invalidate(root.store.getState()));\n    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60\n\n    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it\n\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n\n  function advance(timestamp, runGlobalEffects = true, state) {\n    if (runGlobalEffects) run(globalEffects, timestamp);\n    if (!state) roots.forEach(root => render$1(timestamp, root.store.getState()));else render$1(timestamp, state);\n    if (runGlobalEffects) run(globalAfterEffects, timestamp);\n  }\n\n  return {\n    loop,\n    invalidate,\n    advance\n  };\n}\n\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  const names = {\n    onClick: ['click', false],\n    onContextMenu: ['contextmenu', false],\n    onDoubleClick: ['dblclick', false],\n    onWheel: ['wheel', true],\n    onPointerDown: ['pointerdown', true],\n    onPointerUp: ['pointerup', true],\n    onPointerLeave: ['pointerleave', true],\n    onPointerMove: ['pointermove', true],\n    onPointerCancel: ['pointercancel', true],\n    onLostPointerCapture: ['lostpointercapture', true]\n  };\n  return {\n    connected: false,\n    handlers: Object.keys(names).reduce((acc, key) => ({ ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    connect: target => {\n      var _events$handlers;\n\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: { ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\n        const [eventName, passive] = names[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n\n      if (events.connected) {\n        var _events$handlers2;\n\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = names[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: { ...state.events,\n            connected: false\n          }\n        }));\n      }\n    }\n  };\n}\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, []);\n  return null;\n}\n\nclass ErrorBoundary extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n\n  componentDidCatch(error) {\n    this.props.set(error);\n  }\n\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n\n}\n\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\n\nconst Canvas = /*#__PURE__*/React.forwardRef(function Canvas({\n  children,\n  fallback,\n  tabIndex,\n  resize,\n  id,\n  style,\n  className,\n  events,\n  ...props\n}, forwardedRef) {\n  const [containerRef, {\n    width,\n    height\n  }] = useMeasure({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = React.useRef(null);\n  const [block, setBlock] = React.useState(false);\n  const [error, setError] = React.useState(false); // Suspend this component if block is a promise (2nd run)\n\n  if (block) throw block; // Throw exception outwards if anything within canvas throws\n\n  if (error) throw error; // Execute JSX in the reconciler as a layout-effect\n\n  useIsomorphicLayoutEffect(() => {\n    if (width > 0 && height > 0) {\n      render( /*#__PURE__*/React.createElement(ErrorBoundary, {\n        set: setError\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: /*#__PURE__*/React.createElement(Block, {\n          set: setBlock\n        })\n      }, children)), canvasRef.current, { ...props,\n        size: {\n          width,\n          height\n        },\n        events: events || createPointerEvents\n      });\n    }\n  }, [width, height, children]);\n  useIsomorphicLayoutEffect(() => {\n    const container = canvasRef.current;\n    return () => unmountComponentAtNode(container);\n  }, []);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    id: id,\n    className: className,\n    tabIndex: tabIndex,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      ...style\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: mergeRefs([canvasRef, forwardedRef]),\n    style: {\n      display: 'block'\n    }\n  }, fallback));\n});\n\nfunction useStore() {\n  const store = React.useContext(context);\n  if (!store) throw `R3F hooks can only be used within the Canvas component!`;\n  return store;\n}\nfunction useThree(selector = state => state, equalityFn) {\n  return useStore()(selector, equalityFn);\n}\nfunction useFrame(callback, renderPriority = 0) {\n  const subscribe = useStore().getState().internal.subscribe; // Update ref\n\n  const ref = React.useRef(callback);\n  React.useLayoutEffect(() => void (ref.current = callback), [callback]); // Subscribe on mount, unsubscribe on unmount\n\n  React.useLayoutEffect(() => subscribe(ref, renderPriority), [renderPriority, subscribe]);\n  return null;\n}\n\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) {\n        data.nodes[obj.name] = obj;\n      }\n\n      if (obj.material && !data.materials[obj.material.name]) {\n        data.materials[obj.material.name] = obj.material;\n      }\n    });\n  }\n\n  return data;\n}\n\nfunction useGraph(object) {\n  return React.useMemo(() => buildGraph(object), [object]);\n}\n\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    // Construct new loader and run extensions\n    const loader = new Proto();\n    if (extensions) extensions(loader); // Go through the urls and load them\n\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(`Could not load ${input}: ${error.message}`)))));\n  };\n}\n\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = useAsset(loadingFn(extensions, onProgress), Proto, ...keys); // Return the object/s\n\n  return Array.isArray(input) ? results : results[0];\n}\n\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.preload(loadingFn(extensions), Proto, ...keys);\n};\n\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.clear(Proto, ...keys);\n};\n\nconst roots = new Map();\nconst modes = ['legacy', 'blocking', 'concurrent'];\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer();\n\nconst createRendererInstance = (gl, canvas) => {\n  const customRenderer = typeof gl === 'function' ? gl(canvas) : gl;\n  if (isRenderer(customRenderer)) return customRenderer;\n  const renderer = new THREE.WebGLRenderer({\n    powerPreference: 'high-performance',\n    canvas: canvas,\n    antialias: true,\n    alpha: true,\n    ...gl\n  });\n  if (gl) applyProps(renderer, gl);\n  return renderer;\n};\n\nfunction render(element, canvas, {\n  gl,\n  size,\n  mode = modes[1],\n  events,\n  onCreated,\n  ...props\n} = {}) {\n  var _store;\n\n  // Allow size to take on container bounds initially\n  if (!size) {\n    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;\n\n    size = {\n      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,\n      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0\n    };\n  }\n\n  let root = roots.get(canvas);\n  let fiber = root == null ? void 0 : root.fiber;\n  let store = root == null ? void 0 : root.store;\n  let state = (_store = store) == null ? void 0 : _store.getState();\n\n  if (fiber && state) {\n    // When a root was found, see if any fundamental props must be changed or exchanged\n    // Check pixelratio\n    if (props.dpr !== undefined && !is.equ(state.viewport.dpr, calculateDpr(props.dpr))) state.setDpr(props.dpr); // Check size\n\n    if (state.size.width !== size.width || state.size.height !== size.height) state.setSize(size.width, size.height); // For some props we want to reset the entire root\n    // Changes to the color-space\n\n    const linearChanged = props.linear !== state.internal.lastProps.linear;\n\n    if (linearChanged) {\n      unmountComponentAtNode(canvas);\n      fiber = undefined;\n    }\n  }\n\n  if (!fiber) {\n    // If no root has been found, make one\n    // Create gl\n    const glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested\n\n    if (props.vr) {\n      glRenderer.xr.enabled = true;\n      glRenderer.setAnimationLoop(timestamp => advance(timestamp, true));\n    } // Create store\n\n\n    store = createStore(applyProps, invalidate, advance, {\n      gl: glRenderer,\n      size,\n      ...props\n    });\n    const state = store.getState(); // Create renderer\n\n    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it\n\n    roots.set(canvas, {\n      fiber,\n      store\n    }); // Store events internally\n\n    if (events) state.set({\n      events: events(store)\n    });\n  }\n\n  if (store && fiber) {\n    reconciler.updateContainer( /*#__PURE__*/React.createElement(Provider, {\n      store: store,\n      element: element,\n      onCreated: onCreated,\n      target: canvas\n    }), fiber, null, () => undefined);\n    return store;\n  } else {\n    throw 'Error creating root!';\n  }\n}\n\nfunction Provider({\n  store,\n  element,\n  onCreated,\n  target\n}) {\n  React.useEffect(() => {\n    const state = store.getState(); // Flag the canvas active, rendering will now begin\n\n    state.set(state => ({\n      internal: { ...state.internal,\n        active: true\n      }\n    })); // Connect events\n\n    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n\n    if (onCreated) onCreated(state);\n  }, []);\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: store\n  }, element);\n}\n\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          var _state$gl, _state$gl$renderLists, _state$gl2;\n\n          state.events.disconnect == null ? void 0 : state.events.disconnect();\n          (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n          (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n          dispose(state);\n          roots.delete(canvas);\n          if (callback) callback(canvas);\n        }, 500);\n      }\n    });\n  }\n}\n\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n\n  for (const p in obj) {\n    var _dispose, _ref;\n    (_dispose = (_ref = p).dispose) == null ? void 0 : _dispose.call(_ref);\n    delete obj[p];\n  }\n}\n\nconst act = reconciler.act;\n\nfunction createPortal(children, container) {\n  return reconciler.createPortal(children, container, null, null);\n}\n\nreconciler.injectIntoDevTools({\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: '17.0.2'\n});\n\nexport { Canvas, threeTypes as ReactThreeFiber, roots as _roots, act, addAfterEffect, addEffect, addTail, advance, applyProps, context, createPortal, dispose, createPointerEvents as events, extend, invalidate, reconciler, render, unmountComponentAtNode, useFrame, useGraph, useLoader, useStore, useThree };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAOC,MAAP,MAAmB,SAAnB;AACA,OAAOC,OAAP,MAAoB,iBAApB;AACA,OAAOC,UAAP,MAAuB,kBAAvB;AACA,SAASC,YAAT,EAAuBC,wBAAvB,EAAiDC,qBAAjD,QAA8E,WAA9E;AACA,SAASC,QAAT,QAAyB,WAAzB;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,OAAOC,UAAP,MAAuB,mBAAvB;AAEA,IAAIC,UAAU,GAAG,aAAaC,MAAM,CAACC,MAAP,CAAc;EAC1CC,SAAS,EAAE;AAD+B,CAAd,CAA9B;AAIA,MAAMC,EAAE,GAAG;EACTC,GAAG,EAAEC,CAAC,IAAIA,CAAC,KAAKL,MAAM,CAACK,CAAD,CAAZ,IAAmB,CAACF,EAAE,CAACG,GAAH,CAAOD,CAAP,CAApB,IAAiC,OAAOA,CAAP,KAAa,UAD/C;EAETE,GAAG,EAAEF,CAAC,IAAI,OAAOA,CAAP,KAAa,UAFd;EAGTG,GAAG,EAAEH,CAAC,IAAI,OAAOA,CAAP,KAAa,QAHd;EAITI,GAAG,EAAEJ,CAAC,IAAI,OAAOA,CAAP,KAAa,QAJd;EAKTK,GAAG,EAAEL,CAAC,IAAIA,CAAC,KAAK,KAAK,CALZ;EAMTC,GAAG,EAAED,CAAC,IAAIM,KAAK,CAACC,OAAN,CAAcP,CAAd,CAND;;EAQTQ,GAAG,CAACR,CAAD,EAAIS,CAAJ,EAAO;IACR;IACA,IAAI,OAAOT,CAAP,KAAa,OAAOS,CAApB,IAAyB,CAAC,CAACT,CAAF,KAAQ,CAAC,CAACS,CAAvC,EAA0C,OAAO,KAAP,CAFlC,CAEgD;;IAExD,IAAIX,EAAE,CAACK,GAAH,CAAOH,CAAP,KAAaF,EAAE,CAACM,GAAH,CAAOJ,CAAP,CAAb,IAA0BF,EAAE,CAACC,GAAH,CAAOC,CAAP,CAA9B,EAAyC,OAAOA,CAAC,KAAKS,CAAb,CAJjC,CAIiD;;IAEzD,IAAIX,EAAE,CAACG,GAAH,CAAOD,CAAP,KAAaA,CAAC,IAAIS,CAAtB,EAAyB,OAAO,IAAP,CANjB,CAM8B;;IAEtC,IAAIC,CAAJ;;IAEA,KAAKA,CAAL,IAAUV,CAAV,EAAa,IAAI,EAAEU,CAAC,IAAID,CAAP,CAAJ,EAAe,OAAO,KAAP;;IAE5B,KAAKC,CAAL,IAAUD,CAAV,EAAa,IAAIT,CAAC,CAACU,CAAD,CAAD,KAASD,CAAC,CAACC,CAAD,CAAd,EAAmB,OAAO,KAAP;;IAEhC,OAAOZ,EAAE,CAACO,GAAH,CAAOK,CAAP,IAAYV,CAAC,KAAKS,CAAlB,GAAsB,IAA7B;EACD;;AAvBQ,CAAX;;AA2BA,SAASE,MAAT,CAAgBC,KAAhB,EAAuB;EACrB,OAAO,CAACA,KAAK,CAACC,WAAN,IAAqBD,KAAK,CAACE,MAA5B,EAAoCC,IAApC,GAA2C,GAA3C,GAAiDH,KAAK,CAACI,KAAvD,GAA+DJ,KAAK,CAACK,UAA5E;AACD;;AAED,SAASC,mBAAT,CAA6BC,KAA7B,EAAoCL,MAApC,EAA4C;EAC1C,MAAM;IACJM;EADI,IAEFD,KAAK,CAACE,QAAN,EAFJ,CAD0C,CAGpB;;EAEtBD,QAAQ,CAACE,WAAT,GAAuBF,QAAQ,CAACE,WAAT,CAAqBC,MAArB,CAA4BC,CAAC,IAAIA,CAAC,KAAKV,MAAvC,CAAvB;EACAM,QAAQ,CAACK,WAAT,GAAuBL,QAAQ,CAACK,WAAT,CAAqBF,MAArB,CAA4BC,CAAC,IAAIA,CAAC,KAAKV,MAAvC,CAAvB;EACAM,QAAQ,CAACM,OAAT,CAAiBC,OAAjB,CAAyB,CAACC,KAAD,EAAQC,GAAR,KAAgB;IACvC,IAAID,KAAK,CAACf,WAAN,KAAsBC,MAAtB,IAAgCc,KAAK,CAACd,MAAN,KAAiBA,MAArD,EAA6D;MAC3DM,QAAQ,CAACM,OAAT,CAAiBI,MAAjB,CAAwBD,GAAxB;IACD;EACF,CAJD;AAKD;;AACD,SAASE,YAAT,CAAsBZ,KAAtB,EAA6B;EAC3B,MAAMa,IAAI,GAAG,IAAIjD,KAAK,CAACkD,OAAV,EAAb;EACA;;EAEA,SAASC,UAAT,CAAoBtB,KAApB,EAA2B;IACzB,IAAIuB,qBAAJ;;IAEA,MAAMC,KAAK,GAAGjB,KAAK,CAACE,QAAN,EAAd;IACA,MAAM;MACJgB,SADI;MAEJC,KAFI;MAGJC,MAHI;MAIJC;IAJI,IAKFJ,KALJ,CAJyB,CASd;IACX;;IAEA,MAAM;MACJK,OADI;MAEJC;IAFI,IAGF,CAACP,qBAAqB,GAAGE,SAAS,CAACM,cAAV,IAA4B,IAA5B,GAAmC,KAAK,CAAxC,GAA4CN,SAAS,CAACM,cAAV,CAAyB/B,KAAzB,EAAgCwB,KAAhC,CAArE,KAAgH,IAAhH,GAAuHD,qBAAvH,GAA+IvB,KAHnJ;IAIA,MAAM;MACJgC,KADI;MAEJC;IAFI,IAGFL,IAHJ;IAIAF,KAAK,CAACQ,GAAN,CAAUL,OAAO,GAAGG,KAAV,GAAkB,CAAlB,GAAsB,CAAhC,EAAmC,EAAEF,OAAO,GAAGG,MAAZ,IAAsB,CAAtB,GAA0B,CAA7D;IACAR,SAAS,CAACU,aAAV,CAAwBT,KAAxB,EAA+BC,MAA/B;EACD;EACD;;;EAGA,SAASS,iBAAT,CAA2BpC,KAA3B,EAAkC;IAChC,MAAM;MACJQ;IADI,IAEFD,KAAK,CAACE,QAAN,EAFJ;IAGA,MAAM4B,EAAE,GAAGrC,KAAK,CAAC6B,OAAN,GAAgBrB,QAAQ,CAAC8B,YAAT,CAAsB,CAAtB,CAA3B;IACA,MAAMC,EAAE,GAAGvC,KAAK,CAAC8B,OAAN,GAAgBtB,QAAQ,CAAC8B,YAAT,CAAsB,CAAtB,CAA3B;IACA,OAAOE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,IAAL,CAAUL,EAAE,GAAGA,EAAL,GAAUE,EAAE,GAAGA,EAAzB,CAAX,CAAP;EACD;EACD;;;EAGA,SAASI,mBAAT,CAA6BC,OAA7B,EAAsC;IACpC,OAAOA,OAAO,CAACjC,MAAR,CAAexB,GAAG,IAAI,CAAC,MAAD,EAAS,MAAT,EAAiB,OAAjB,EAA0B,KAA1B,EAAiC,OAAjC,EAA0C0D,IAA1C,CAA+CC,IAAI,IAAI;MAClF,IAAIC,IAAJ;;MAEA,OAAO,CAACA,IAAI,GAAG5D,GAAG,CAAC6D,KAAZ,KAAsB,IAAtB,GAA6B,KAAK,CAAlC,GAAsCD,IAAI,CAACE,QAAL,CAAc,cAAcH,IAA5B,CAA7C;IACD,CAJ4B,CAAtB,CAAP;EAKD;;EAED,SAASI,SAAT,CAAmBvC,MAAnB,EAA2B;IACzB,MAAMa,KAAK,GAAGjB,KAAK,CAACE,QAAN,EAAd;IACA,MAAM;MACJgB,SADI;MAEJjB;IAFI,IAGFgB,KAHJ,CAFyB,CAKd;;IAEX,IAAI,CAACC,SAAS,CAAC0B,OAAf,EAAwB,OAAO,EAAP;IACxB,MAAMC,IAAI,GAAG,IAAIC,GAAJ,EAAb;IACA,MAAMC,aAAa,GAAG,EAAtB,CATyB,CASC;;IAE1B,MAAMC,aAAa,GAAG5C,MAAM,GAAGA,MAAM,CAACH,QAAQ,CAACE,WAAV,CAAT,GAAkCF,QAAQ,CAACE,WAAvE,CAXyB,CAW2D;;IAEpF,IAAI8C,UAAU,GAAG/B,SAAS,CAACgC,gBAAV,CAA2BF,aAA3B,EAA0C,IAA1C,EAAgD5C,MAAhD,CAAuD+C,IAAI,IAAI;MAC9E,MAAMC,EAAE,GAAG5D,MAAM,CAAC2D,IAAD,CAAjB;MACA,IAAIN,IAAI,CAACQ,GAAL,CAASD,EAAT,CAAJ,EAAkB,OAAO,KAAP;MAClBP,IAAI,CAACS,GAAL,CAASF,EAAT;MACA,OAAO,IAAP;IACD,CALgB,CAAjB,CAbyB,CAkBrB;IACJ;;IAEA,IAAIlC,SAAS,CAACd,MAAd,EAAsB6C,UAAU,GAAG/B,SAAS,CAACd,MAAV,CAAiB6C,UAAjB,EAA6BhC,KAA7B,CAAb;;IAEtB,KAAK,MAAM0B,SAAX,IAAwBM,UAAxB,EAAoC;MAClC,IAAIvD,WAAW,GAAGiD,SAAS,CAAChD,MAA5B,CADkC,CACE;;MAEpC,OAAOD,WAAP,EAAoB;QAClB,IAAI6D,KAAJ;;QAEA,IAAI,CAACA,KAAK,GAAG7D,WAAW,CAAC+C,KAArB,KAA+B,IAA/B,IAAuCc,KAAK,CAACb,QAAN,CAAec,KAA1D,EAAiET,aAAa,CAACU,IAAd,CAAmB,EAAE,GAAGd,SAAL;UAClFjD;QADkF,CAAnB;QAGjEA,WAAW,GAAGA,WAAW,CAACgE,MAA1B;MACD;IACF;;IAED,OAAOX,aAAP;EACD;EACD;;;EAGA,SAASY,eAAT,CAAyBZ,aAAzB,EAAwCtD,KAAxC,EAA+C;IAC7C,MAAM;MACJQ;IADI,IAEFD,KAAK,CAACE,QAAN,EAFJ,CAD6C,CAGvB;IACtB;;IAEA,IAAI,eAAeT,KAAf,IAAwBQ,QAAQ,CAAC2D,WAAT,CAAqBP,GAArB,CAAyB5D,KAAK,CAACoE,SAA/B,CAA5B,EAAuE;MACrEd,aAAa,CAACU,IAAd,CAAmB,GAAGxD,QAAQ,CAAC2D,WAAT,CAAqBE,GAArB,CAAyBrE,KAAK,CAACoE,SAA/B,EAA0CE,MAA1C,EAAtB;IACD;;IAED,OAAOhB,aAAP;EACD;EACD;;;EAGA,SAASiB,gBAAT,CAA0BjB,aAA1B,EAAyCtD,KAAzC,EAAgDwE,KAAhD,EAAuDC,QAAvD,EAAiE;IAC/D,MAAM;MACJhD,SADI;MAEJC,KAFI;MAGJC,MAHI;MAIJnB;IAJI,IAKFD,KAAK,CAACE,QAAN,EALJ,CAD+D,CAMzC;;IAEtB,IAAI6C,aAAa,CAACoB,MAAlB,EAA0B;MACxB,MAAMC,gBAAgB,GAAGvD,IAAI,CAACc,GAAL,CAASR,KAAK,CAACkD,CAAf,EAAkBlD,KAAK,CAACmD,CAAxB,EAA2B,CAA3B,EAA8BC,SAA9B,CAAwCnD,MAAxC,CAAzB;;MAEA,MAAMoD,qBAAqB,GAAGpB,EAAE,IAAI3D,KAAK,CAACgF,MAAN,CAAaD,qBAAb,CAAmCpB,EAAnC,CAApC;;MAEA,MAAMsB,UAAU,GAAG;QACjBC,OAAO,EAAE;MADQ,CAAnB;;MAIA,KAAK,MAAMC,GAAX,IAAkB7B,aAAlB,EAAiC;QAC/B,MAAM8B,iBAAiB,GAAGzB,EAAE,IAAI;UAC9B,IAAI0B,qBAAJ,EAA2BC,sBAA3B;;UAEA,OAAO,CAACD,qBAAqB,GAAG,CAACC,sBAAsB,GAAG9E,QAAQ,CAAC2D,WAAT,CAAqBE,GAArB,CAAyBV,EAAzB,CAA1B,KAA2D,IAA3D,GAAkE,KAAK,CAAvE,GAA2E2B,sBAAsB,CAAC1B,GAAvB,CAA2BuB,GAAG,CAAClF,WAA/B,CAApG,KAAoJ,IAApJ,GAA2JoF,qBAA3J,GAAmL,KAA1L;QACD,CAJD;;QAMA,MAAME,iBAAiB,GAAG5B,EAAE,IAAI;UAC9B,IAAInD,QAAQ,CAAC2D,WAAT,CAAqBP,GAArB,CAAyBD,EAAzB,CAAJ,EAAkC;YAChC;YACA;YACAnD,QAAQ,CAAC2D,WAAT,CAAqBE,GAArB,CAAyBV,EAAzB,EAA6BzB,GAA7B,CAAiCiD,GAAG,CAAClF,WAArC,EAAkDkF,GAAlD;UACD,CAJD,MAIO;YACL;YACA;YACA;YACA3E,QAAQ,CAAC2D,WAAT,CAAqBjC,GAArB,CAAyByB,EAAzB,EAA6B,IAAI6B,GAAJ,CAAQ,CAAC,CAACL,GAAG,CAAClF,WAAL,EAAkBkF,GAAlB,CAAD,CAAR,CAA7B;UACD,CAV6B,CAU5B;;;UACFnF,KAAK,CAACgF,MAAN,CAAaO,iBAAb,CAA+B5B,EAA/B;QACD,CAZD,CAP+B,CAmB5B;;;QAGH,IAAI8B,iBAAiB,GAAG,EAAxB;;QAEA,KAAK,IAAIC,IAAT,IAAiB3G,MAAM,CAAC4G,cAAP,CAAsB3F,KAAtB,CAAjB,EAA+C;UAC7C,IAAI4F,QAAQ,GAAG5F,KAAK,CAAC0F,IAAD,CAApB,CAD6C,CACjB;UAC5B;;UAEA,IAAI,OAAOE,QAAP,KAAoB,UAAxB,EAAoCH,iBAAiB,CAACC,IAAD,CAAjB,GAA0BE,QAA1B;QACrC;;QAED,IAAIC,YAAY,GAAG,EAAE,GAAGV,GAAL;UACjB,GAAGM,iBADc;UAEjBK,MAAM,EAAEpE,KAAK,CAACkD,CAFG;UAGjBmB,MAAM,EAAErE,KAAK,CAACmD,CAHG;UAIjBvB,aAJiB;UAKjB4B,OAAO,EAAED,UAAU,CAACC,OALH;UAMjBV,KANiB;UAOjBG,gBAPiB;UAQjBqB,GAAG,EAAEvE,SAAS,CAACuE,GARE;UASjBrE,MAAM,EAAEA,MATS;UAUjB;UACAsE,eAAe,EAAE,MAAM;YACrB;YACA;YACA,MAAMC,kBAAkB,GAAG,eAAelG,KAAf,IAAwBQ,QAAQ,CAAC2D,WAAT,CAAqBE,GAArB,CAAyBrE,KAAK,CAACoE,SAA/B,CAAnD,CAHqB,CAGyE;;YAE9F,KAAK;YACL,CAAC8B,kBAAD,IAAuB;YACvBA,kBAAkB,CAACtC,GAAnB,CAAuBuB,GAAG,CAAClF,WAA3B,CAFA,EAEyC;cACvC4F,YAAY,CAACX,OAAb,GAAuBD,UAAU,CAACC,OAAX,GAAqB,IAA5C,CADuC,CACW;cAClD;;cAEA,IAAI1E,QAAQ,CAACM,OAAT,CAAiBc,IAAjB,IAAyBlC,KAAK,CAACyG,IAAN,CAAW3F,QAAQ,CAACM,OAAT,CAAiBwD,MAAjB,EAAX,EAAsC8B,IAAtC,CAA2CtG,CAAC,IAAIA,CAAC,CAACG,WAAF,KAAkBkF,GAAG,CAAClF,WAAtE,CAA7B,EAAiH;gBAC/G;gBACA,MAAMoG,MAAM,GAAG/C,aAAa,CAACgD,KAAd,CAAoB,CAApB,EAAuBhD,aAAa,CAACiD,OAAd,CAAsBpB,GAAtB,CAAvB,CAAf;gBACAqB,aAAa,CAAC,CAAC,GAAGH,MAAJ,EAAYlB,GAAZ,CAAD,CAAb;cACD;YACF;UACF,CA5BgB;UA6BjB;UACAH,MAAM,EAAE;YACNI,iBADM;YAENG,iBAFM;YAGNR;UAHM,CA9BS;UAmCjB0B,aAAa,EAAE;YACbrB,iBADa;YAEbG,iBAFa;YAGbR;UAHa,CAnCE;UAwCjB2B,WAAW,EAAE1G,KAxCI;UAyCjB;UACA2G,WAAW,EAAE3G;QA1CI,CAAnB,CA/B+B,CA0E5B;;QAEHyE,QAAQ,CAACoB,YAAD,CAAR,CA5E+B,CA4EP;;QAExB,IAAIZ,UAAU,CAACC,OAAX,KAAuB,IAA3B,EAAiC;MAClC;IACF;;IAED,OAAO5B,aAAP;EACD;;EAED,SAASkD,aAAT,CAAuBI,IAAvB,EAA6B;IAC3B,MAAM;MACJpG;IADI,IAEFD,KAAK,CAACE,QAAN,EAFJ;IAGAf,KAAK,CAACyG,IAAN,CAAW3F,QAAQ,CAACM,OAAT,CAAiBwD,MAAjB,EAAX,EAAsCvD,OAAtC,CAA8C8F,UAAU,IAAI;MAC1D;MACA;MACA,IAAI,CAACD,IAAI,CAAClC,MAAN,IAAgB,CAACkC,IAAI,CAACR,IAAL,CAAUjB,GAAG,IAAIA,GAAG,CAACjF,MAAJ,KAAe2G,UAAU,CAAC3G,MAA1B,IAAoCiF,GAAG,CAAC/E,KAAJ,KAAcyG,UAAU,CAACzG,KAA7D,IAAsE+E,GAAG,CAAC9E,UAAJ,KAAmBwG,UAAU,CAACxG,UAArH,CAArB,EAAuJ;QACrJ,IAAIyG,KAAJ;;QAEA,MAAM7G,WAAW,GAAG4G,UAAU,CAAC5G,WAA/B;QACA,MAAMgD,QAAQ,GAAG,CAAC6D,KAAK,GAAG7G,WAAW,CAAC+C,KAArB,KAA+B,IAA/B,GAAsC,KAAK,CAA3C,GAA+C8D,KAAK,CAAC7D,QAAtE;QACAzC,QAAQ,CAACM,OAAT,CAAiBI,MAAjB,CAAwBnB,MAAM,CAAC8G,UAAD,CAA9B;;QAEA,IAAI5D,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,CAACc,KAAjC,EAAwC;UACtC;UACA,MAAMgD,IAAI,GAAG,EAAE,GAAGF,UAAL;YACXvD,aAAa,EAAEsD,IAAI,IAAI;UADZ,CAAb;UAGA3D,QAAQ,CAAC+D,YAAT,IAAyB,IAAzB,GAAgC,KAAK,CAArC,GAAyC/D,QAAQ,CAAC+D,YAAT,CAAsBD,IAAtB,CAAzC;UACA9D,QAAQ,CAACgE,cAAT,IAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2ChE,QAAQ,CAACgE,cAAT,CAAwBF,IAAxB,CAA3C;QACD;MACF;IACF,CAnBD;EAoBD;;EAED,MAAMG,aAAa,GAAGpE,IAAI,IAAI;IAC5B;IACA,QAAQA,IAAR;MACE,KAAK,gBAAL;MACA,KAAK,iBAAL;QACE,OAAO,MAAM0D,aAAa,CAAC,EAAD,CAA1B;;MAEF,KAAK,sBAAL;QACE,OAAOxG,KAAK,IAAI;UACd,IAAI,eAAeA,KAAnB,EAA0B;YACxB;YACA;YACA;YACAO,KAAK,CAACE,QAAN,GAAiBD,QAAjB,CAA0B2D,WAA1B,CAAsCjD,MAAtC,CAA6ClB,KAAK,CAACoE,SAAnD;UACD;;UAEDoC,aAAa,CAAC,EAAD,CAAb;QACD,CATD;IANJ,CAF4B,CAkB1B;;;IAGF,OAAOxG,KAAK,IAAI;MACd,MAAM;QACJmH,eADI;QAEJ3G;MAFI,IAGFD,KAAK,CAACE,QAAN,EAHJ;MAIAa,UAAU,CAACtB,KAAD,CAAV,CALc,CAKK;;MAEnB,MAAMoH,aAAa,GAAGtE,IAAI,KAAK,eAA/B;MACA,MAAMuE,YAAY,GAAGvE,IAAI,KAAK,SAAT,IAAsBA,IAAI,KAAK,eAA/B,IAAkDA,IAAI,KAAK,eAAhF;MACA,MAAMnC,MAAM,GAAGyG,aAAa,GAAGzE,mBAAH,GAAyB2E,SAArD;MACA,MAAMV,IAAI,GAAG1C,eAAe,CAAChB,SAAS,CAACvC,MAAD,CAAV,EAAoBX,KAApB,CAA5B;MACA,MAAMwE,KAAK,GAAG6C,YAAY,GAAGjF,iBAAiB,CAACpC,KAAD,CAApB,GAA8B,CAAxD,CAXc,CAW6C;;MAE3D,IAAI8C,IAAI,KAAK,eAAb,EAA8B;QAC5BtC,QAAQ,CAAC8B,YAAT,GAAwB,CAACtC,KAAK,CAAC6B,OAAP,EAAgB7B,KAAK,CAAC8B,OAAtB,CAAxB;QACAtB,QAAQ,CAACK,WAAT,GAAuB+F,IAAI,CAACW,GAAL,CAASpC,GAAG,IAAIA,GAAG,CAAClF,WAApB,CAAvB;MACD,CAhBa,CAgBZ;MACF;;;MAGA,IAAIoH,YAAY,IAAI,CAACT,IAAI,CAAClC,MAA1B,EAAkC;QAChC,IAAIF,KAAK,IAAI,CAAb,EAAgB;UACdgD,aAAa,CAACxH,KAAD,EAAQQ,QAAQ,CAACE,WAAjB,CAAb;UACA,IAAIyG,eAAJ,EAAqBA,eAAe,CAACnH,KAAD,CAAf;QACtB;MACF,CAzBa,CAyBZ;;;MAGF,IAAIoH,aAAJ,EAAmBZ,aAAa,CAACI,IAAD,CAAb;MACnBrC,gBAAgB,CAACqC,IAAD,EAAO5G,KAAP,EAAcwE,KAAd,EAAqBuC,IAAI,IAAI;QAC3C,IAAIU,KAAJ;;QAEA,MAAMxH,WAAW,GAAG8G,IAAI,CAAC9G,WAAzB;QACA,MAAMgD,QAAQ,GAAG,CAACwE,KAAK,GAAGxH,WAAW,CAAC+C,KAArB,KAA+B,IAA/B,GAAsC,KAAK,CAA3C,GAA+CyE,KAAK,CAACxE,QAAtE,CAJ2C,CAIqC;;QAEhF,IAAI,EAAEA,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,CAACc,KAA/B,CAAJ,EAA2C;;QAE3C,IAAIqD,aAAJ,EAAmB;UACjB;UACA,IAAInE,QAAQ,CAACyE,aAAT,IAA0BzE,QAAQ,CAAC0E,cAAnC,IAAqD1E,QAAQ,CAAC+D,YAA9D,IAA8E/D,QAAQ,CAACgE,cAA3F,EAA2G;YACzG;YACA,MAAMtD,EAAE,GAAG5D,MAAM,CAACgH,IAAD,CAAjB;YACA,MAAMa,WAAW,GAAGpH,QAAQ,CAACM,OAAT,CAAiBuD,GAAjB,CAAqBV,EAArB,CAApB;;YAEA,IAAI,CAACiE,WAAL,EAAkB;cAChB;cACApH,QAAQ,CAACM,OAAT,CAAiBoB,GAAjB,CAAqByB,EAArB,EAAyBoD,IAAzB;cACA9D,QAAQ,CAACyE,aAAT,IAA0B,IAA1B,GAAiC,KAAK,CAAtC,GAA0CzE,QAAQ,CAACyE,aAAT,CAAuBX,IAAvB,CAA1C;cACA9D,QAAQ,CAAC0E,cAAT,IAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2C1E,QAAQ,CAAC0E,cAAT,CAAwBZ,IAAxB,CAA3C;YACD,CALD,MAKO,IAAIa,WAAW,CAAC1C,OAAhB,EAAyB;cAC9B;cACA6B,IAAI,CAACd,eAAL;YACD;UACF,CAhBgB,CAgBf;;;UAGFhD,QAAQ,CAAC4E,aAAT,IAA0B,IAA1B,GAAiC,KAAK,CAAtC,GAA0C5E,QAAQ,CAAC4E,aAAT,CAAuBd,IAAvB,CAA1C;QACD,CApBD,MAoBO;UACL;UACA,MAAMe,OAAO,GAAG7E,QAAQ,CAACH,IAAD,CAAxB;;UAEA,IAAIgF,OAAJ,EAAa;YACX;YACA;YACA,IAAIhF,IAAI,KAAK,SAAT,IAAsBA,IAAI,KAAK,eAA/B,IAAkDA,IAAI,KAAK,eAA3D,IAA8EtC,QAAQ,CAACK,WAAT,CAAqBkH,QAArB,CAA8B9H,WAA9B,CAAlF,EAA8H;cAC5H;cACAuH,aAAa,CAACxH,KAAD,EAAQQ,QAAQ,CAACE,WAAT,CAAqBC,MAArB,CAA4BT,MAAM,IAAI,CAACM,QAAQ,CAACK,WAAT,CAAqBkH,QAArB,CAA8B7H,MAA9B,CAAvC,CAAR,CAAb,CAF4H,CAEvB;;cAErG4H,OAAO,CAACf,IAAD,CAAP;YACD;UACF;QACF;MACF,CA3Ce,CAAhB;IA4CD,CAzED;EA0ED,CA/FD;;EAiGA,SAASS,aAAT,CAAuBxH,KAAvB,EAA8B4C,OAA9B,EAAuC;IACrCA,OAAO,CAAC7B,OAAR,CAAgBb,MAAM,IAAI;MACxB,IAAI8H,KAAJ;;MAEA,OAAO,CAACA,KAAK,GAAG9H,MAAM,CAAC8C,KAAhB,KAA0B,IAA1B,GAAiC,KAAK,CAAtC,GAA0CgF,KAAK,CAAC/E,QAAN,CAAekE,eAAf,IAAkC,IAAlC,GAAyC,KAAK,CAA9C,GAAkDa,KAAK,CAAC/E,QAAN,CAAekE,eAAf,CAA+BnH,KAA/B,CAAnG;IACD,CAJD;EAKD;;EAED,OAAO;IACLkH;EADK,CAAP;AAGD;;AAED,MAAMe,SAAS,GAAGC,GAAG,IAAIA,GAAG,IAAI,CAAC,CAACA,GAAG,CAACC,QAAb,IAAyB,CAAC,CAACD,GAAG,CAACE,OAAxD,C,CAEA;;;AACA,MAAMC,OAAO,GAAGH,GAAG,IAAIA,GAAG,IAAI,CAAC,CAACA,GAAG,CAACzH,QAApC;;AAEA,MAAM6H,YAAY,GAAG,CAACC,SAAD,EAAYC,KAAZ,KAAsB;EACzC,IAAIC,qBAAJ,EAA2BC,gBAA3B;;EAEA,OAAO;IACL;IACA;IACA;IACA;IACAC,IAAI,EAAEN,OAAO,CAACE,SAAD,CAAP,GAAqBA,SAArB,GAAiC,CAACE,qBAAqB,GAAG,CAACC,gBAAgB,GAAGH,SAAS,CAACvF,KAA9B,KAAwC,IAAxC,GAA+C,KAAK,CAApD,GAAwD0F,gBAAgB,CAACC,IAAlG,KAA2G,IAA3G,GAAkHF,qBAAlH,GAA0ID,KAAK,CAACxF,KAAN,CAAY2F,IALxL;IAML;IACAJ,SAAS,EAAEF,OAAO,CAACE,SAAD,CAAP,GAAqBA,SAAS,CAAC9H,QAAV,GAAqBmI,KAA1C,GAAkDL;EAPxD,CAAP;AASD,CAZD;;AAcA,MAAMM,OAAO,GAAG,WAAhB;AACA,MAAMC,KAAK,GAAG,EAAd;AACA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,IAAIC,MAAM,GAAGpG,OAAO,IAAI,MAAMmG,SAAS,GAAG,EAAE,GAAGA,SAAL;EACxC,GAAGnG;AADqC,CAAlB,CAAxB,C,CAEI;;;AAGJ,SAASqG,YAAT,CAAsB7J,CAAtB,EAAyBS,CAAzB,EAA4B;EAC1B,IAAIX,EAAE,CAACG,GAAH,CAAOD,CAAP,KAAaF,EAAE,CAACU,GAAH,CAAOR,CAAP,EAAUS,CAAV,CAAjB,EAA+B,OAAO,IAAP;EAC/B,IAAIT,CAAC,KAAKS,CAAV,EAAa,OAAO,IAAP;EACb,OAAO,KAAP;AACD,C,CAAC;;;AAGF,SAASqJ,OAAT,CAAiBhJ,MAAjB,EAAyBsB,KAAzB,EAAgC;EAC9B,MAAM2H,QAAQ,GAAGjJ,MAAjB;;EAEA,IAAIsB,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAAC4H,SAAvB,IAAoC,CAACD,QAAQ,CAACnG,KAAlD,EAAyD;IACvDmG,QAAQ,CAACnG,KAAT,GAAiB;MACf2F,IAAI,EAAE,IADS;MAEfU,aAAa,EAAE,EAFA;MAGfpG,QAAQ,EAAE;QACRc,KAAK,EAAE;MADC,CAHK;MAMfnB,OAAO,EAAE,EANM;MAOfqB,MAAM,EAAE,IAPO;MAQf,GAAGzC;IARY,CAAjB;EAUD;;EAED,OAAOtB,MAAP;AACD;;AAED,SAASoJ,cAAT,CAAwBC,KAAxB,EAA+B;EAC7B;EACA,SAASC,SAAT,CAAmBL,QAAnB,SAU8B;IAAA,IAVD;MAC3BM,QAAQ,EAAEC,EADiB;MAE3BzI,GAAG,EAAE0I,EAFsB;MAG3BC,GAAG,EAAEC,EAHsB;MAI3B,GAAGC;IAJwB,CAUC;IAAA,IAL3B;MACDL,QAAQ,EAAEM,EADT;MAED9I,GAAG,EAAE+I,EAFJ;MAGDJ,GAAG,EAAEK,EAHJ;MAID,GAAGC;IAJF,CAK2B,uEAA1B,EAA0B;IAAA,IAAtBC,YAAsB,uEAAP,KAAO;;IAC5B,IAAIC,eAAJ;;IAEA,MAAMnF,UAAU,GAAG,CAACmF,eAAe,GAAGjB,QAAQ,IAAI,IAAZ,GAAmB,KAAK,CAAxB,GAA4BA,QAAQ,CAACnG,KAAxD,KAAkE,IAAlE,GAAyEoH,eAAzE,GAA2F,EAA9G;IACA,MAAMC,OAAO,GAAGtL,MAAM,CAACsL,OAAP,CAAeP,KAAf,CAAhB;IACA,MAAM1B,OAAO,GAAG,EAAhB,CAL4B,CAKR;;IAEpB,IAAI+B,YAAJ,EAAkB;MAChB,MAAMG,YAAY,GAAGvL,MAAM,CAACwL,IAAP,CAAYL,QAAZ,CAArB;;MAEA,KAAK,IAAIpK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwK,YAAY,CAAC5F,MAAjC,EAAyC5E,CAAC,EAA1C,EAA8C,IAAI,CAACgK,KAAK,CAACU,cAAN,CAAqBF,YAAY,CAACxK,CAAD,CAAjC,CAAL,EAA4CuK,OAAO,CAACI,OAAR,CAAgB,CAACH,YAAY,CAACxK,CAAD,CAAb,EAAkB+I,OAAO,GAAG,QAA5B,CAAhB;IAC3F;;IAEDwB,OAAO,CAACtJ,OAAR,CAAgB,SAAkB;MAAA,IAAjB,CAACE,GAAD,EAAMD,KAAN,CAAiB;;MAChC,IAAI0J,gBAAJ,CADgC,CAGhC;;;MACA,IAAI,CAACA,gBAAgB,GAAGvB,QAAQ,CAACnG,KAA7B,KAAuC,IAAvC,IAA+C0H,gBAAgB,CAACtB,SAAhE,IAA6EnI,GAAG,KAAK,QAAzF,EAAmG,OAJnE,CAI2E;;MAE3G,IAAIgI,YAAY,CAACjI,KAAD,EAAQkJ,QAAQ,CAACjJ,GAAD,CAAhB,CAAhB,EAAwC,OANR,CAMgB;;MAEhD,IAAI,mDAAmD0J,IAAnD,CAAwD1J,GAAxD,CAAJ,EAAkE,OAAOmH,OAAO,CAACpE,IAAR,CAAa,CAAC/C,GAAD,EAAMD,KAAN,EAAa,IAAb,EAAmB,EAAnB,CAAb,CAAP,CARlC,CAQ+E;;MAE/G,IAAIqJ,OAAO,GAAG,EAAd;MACA,IAAIpJ,GAAG,CAAC8G,QAAJ,CAAa,GAAb,CAAJ,EAAuBsC,OAAO,GAAGpJ,GAAG,CAAC2J,KAAJ,CAAU,GAAV,CAAV;MACvBxC,OAAO,CAACpE,IAAR,CAAa,CAAC/C,GAAD,EAAMD,KAAN,EAAa,KAAb,EAAoBqJ,OAApB,CAAb;IACD,CAbD;IAcA,MAAMlC,QAAQ,GAAG,EAAE,GAAG2B;IAAL,CAAjB;IAEA,IAAI7E,UAAU,CAACoE,aAAX,IAA4BpE,UAAU,CAACoE,aAAX,CAAyBwB,IAAzD,EAA+D1C,QAAQ,CAAC0C,IAAT,GAAgB5F,UAAU,CAACoE,aAAX,CAAyBwB,IAAzC;IAC/D,IAAI5F,UAAU,CAACoE,aAAX,IAA4BpE,UAAU,CAACoE,aAAX,CAAyByB,MAAzD,EAAiE3C,QAAQ,CAAC2C,MAAT,GAAkB7F,UAAU,CAACoE,aAAX,CAAyByB,MAA3C;IACjE,OAAO;MACLX,YADK;MAELhC,QAFK;MAGLC;IAHK,CAAP;EAKD;;EAED,SAAS2C,UAAT,CAAoB5B,QAApB,EAA8BpC,IAA9B,EAAoC;IAClC,IAAIiE,gBAAJ,EAAsBC,cAAtB,EAAsCC,oBAAtC,EAA4DC,qBAA5D,EAAmFC,gBAAnF,CADkC,CAGlC;;;IACA,MAAMnG,UAAU,GAAG,CAAC+F,gBAAgB,GAAG7B,QAAQ,IAAI,IAAZ,GAAmB,KAAK,CAAxB,GAA4BA,QAAQ,CAACnG,KAAzD,KAAmE,IAAnE,GAA0EgI,gBAA1E,GAA6F,EAAhH;IACA,MAAMrC,IAAI,GAAG1D,UAAU,CAAC0D,IAAxB;IACA,MAAM0C,SAAS,GAAG,CAACJ,cAAc,GAAGtC,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAAClI,QAAL,IAAiB,IAAjB,GAAwB,KAAK,CAA7B,GAAiCkI,IAAI,CAAClI,QAAL,EAA3E,KAA+F,IAA/F,GAAsGwK,cAAtG,GAAuH,EAAzI;IACA,MAAM;MACJ9C,QADI;MAEJC;IAFI,IAGFH,SAAS,CAAClB,IAAD,CAAT,GAAkBA,IAAlB,GAAyByC,SAAS,CAACL,QAAD,EAAWpC,IAAX,CAHtC;IAIA,MAAMuE,YAAY,GAAG,CAACJ,oBAAoB,GAAGjG,UAAU,CAAChC,QAAnC,KAAgD,IAAhD,GAAuD,KAAK,CAA5D,GAAgEiI,oBAAoB,CAACnH,KAA1G,CAXkC,CAW+E;;IAEjH,IAAIoF,QAAQ,CAACnG,KAAb,EAAoBmG,QAAQ,CAACnG,KAAT,CAAeqG,aAAf,GAA+BlB,QAA/B;IACpBC,OAAO,CAACrH,OAAR,CAAgB,SAAiC;MAAA,IAAhC,CAACE,GAAD,EAAMD,KAAN,EAAauK,OAAb,EAAsBhB,IAAtB,CAAgC;MAC/C,IAAIiB,eAAe,GAAGrC,QAAtB;MACA,IAAIsC,UAAU,GAAGD,eAAe,CAACvK,GAAD,CAAhC,CAF+C,CAER;;MAEvC,IAAIsJ,IAAI,CAAC7F,MAAT,EAAiB;QACf+G,UAAU,GAAGlB,IAAI,CAACmB,MAAL,CAAY,CAACC,GAAD,EAAM1K,GAAN,KAAc0K,GAAG,CAAC1K,GAAD,CAA7B,EAAoCkI,QAApC,CAAb,CADe,CAC6C;;QAE5D,IAAI,EAAEsC,UAAU,IAAIA,UAAU,CAACvJ,GAA3B,CAAJ,EAAqC;UACnC,MAAM,CAACY,IAAD,EAAO,GAAG8I,cAAV,IAA4BrB,IAAI,CAACsB,OAAL,EAAlC;UACAL,eAAe,GAAGI,cAAc,CAACC,OAAf,GAAyBH,MAAzB,CAAgC,CAACC,GAAD,EAAM1K,GAAN,KAAc0K,GAAG,CAAC1K,GAAD,CAAjD,EAAwDkI,QAAxD,CAAlB;UACAlI,GAAG,GAAG6B,IAAN;QACD;MACF,CAZ8C,CAY7C;MACF;MACA;MACA;MACA;;;MAGA,IAAI9B,KAAK,KAAK6H,OAAO,GAAG,QAAxB,EAAkC;QAChC,IAAI4C,UAAU,IAAIA,UAAU,CAACK,WAA7B,EAA0C;UACxC;UACA9K,KAAK,GAAG,IAAIyK,UAAU,CAACK,WAAf,CAA2B3D,QAAQ,CAAC0C,IAApC,CAAR;QACD,CAHD,MAGO,IAAIW,eAAe,CAACM,WAApB,EAAiC;UACtC;UACA;UACA,MAAMC,gBAAgB,GAAG,IAAIP,eAAe,CAACM,WAApB,CAAgCN,eAAe,CAACxI,KAAhB,CAAsBqG,aAAtB,CAAoCwB,IAApE,CAAzB;UACA7J,KAAK,GAAG+K,gBAAgB,CAACN,UAAD,CAAxB,CAJsC,CAIA;;UAEtC,IAAIM,gBAAgB,CAACC,OAArB,EAA8BD,gBAAgB,CAACC,OAAjB,GANQ,CAMoB;QAC3D,CAPM,MAOAhL,KAAK,GAAG,CAAR;MACR,CA/B8C,CA+B7C;;;MAGF,IAAIuK,OAAJ,EAAa;QACX,IAAIvK,KAAJ,EAAWiE,UAAU,CAAChC,QAAX,CAAoBhC,GAApB,IAA2BD,KAA3B,CAAX,KAAiD,OAAOiE,UAAU,CAAChC,QAAX,CAAoBhC,GAApB,CAAP;QACjDgE,UAAU,CAAChC,QAAX,CAAoBc,KAApB,GAA4BhF,MAAM,CAACwL,IAAP,CAAYtF,UAAU,CAAChC,QAAvB,EAAiCyB,MAA7D;MACD,CAHD,CAGE;MAHF,KAIK,IAAI+G,UAAU,IAAIA,UAAU,CAACvJ,GAAzB,KAAiCuJ,UAAU,CAACQ,IAAX,IAAmBR,UAAU,YAAYtN,KAAK,CAAC+N,MAAhF,CAAJ,EAA6F;QAC9F;QACA,IAAIxM,KAAK,CAACC,OAAN,CAAcqB,KAAd,CAAJ,EAA0B;UACxB,IAAIyK,UAAU,CAACU,SAAf,EAA0BV,UAAU,CAACU,SAAX,CAAqBnL,KAArB,EAA1B,KAA2DyK,UAAU,CAACvJ,GAAX,CAAe,GAAGlB,KAAlB;QAC5D,CAFD,CAEE;QAFF,KAGK,IAAIyK,UAAU,CAACQ,IAAX,IAAmBjL,KAAnB,IAA4BA,KAAK,CAAC8K,WAAlC,IAAiDL,UAAU,CAACK,WAAX,CAAuBhJ,IAAvB,KAAgC9B,KAAK,CAAC8K,WAAN,CAAkBhJ,IAAvG,EAA6G2I,UAAU,CAACQ,IAAX,CAAgBjL,KAAhB,EAA7G,CAAqI;QACxI;QADG,KAEE,IAAIA,KAAK,KAAKsG,SAAd,EAAyB;UAC1B,MAAM8E,OAAO,GAAGX,UAAU,YAAYtN,KAAK,CAACkO,KAA5C,CAD0B,CACyB;;UAEnD,IAAI,CAACD,OAAD,IAAYX,UAAU,CAACa,SAA3B,EAAsCb,UAAU,CAACa,SAAX,CAAqBtL,KAArB,EAAtC,CAAmE;UAAnE,KACK,IAAIyK,UAAU,YAAYtN,KAAK,CAAC+N,MAA5B,IAAsClL,KAAK,YAAY7C,KAAK,CAAC+N,MAAjE,EAAyET,UAAU,CAACc,IAAX,GAAkBvL,KAAK,CAACuL,IAAxB,CAAzE,CAAuG;UAAvG,KACEd,UAAU,CAACvJ,GAAX,CAAelB,KAAf,EALmB,CAKI;UAC9B;;UAEA,IAAI,CAACqK,SAAS,CAACmB,MAAX,IAAqBJ,OAAzB,EAAkCX,UAAU,CAACgB,mBAAX;QACnC,CAhByF,CAgBxF;;MAEP,CAlBE,MAkBI;QACLjB,eAAe,CAACvK,GAAD,CAAf,GAAuBD,KAAvB,CADK,CACyB;QAC9B;;QAEA,IAAI,CAACqK,SAAS,CAACmB,MAAX,IAAqBhB,eAAe,CAACvK,GAAD,CAAf,YAAgC9C,KAAK,CAACuO,OAA/D,EAAwElB,eAAe,CAACvK,GAAD,CAAf,CAAqB0L,QAArB,GAAgCxO,KAAK,CAACyO,YAAtC;MACzE;;MAEHC,kBAAkB,CAAC1D,QAAD,CAAlB;IACD,CAhED;;IAkEA,IAAIkC,SAAS,CAAC7K,QAAV,IAAsB2I,QAAQ,CAAC2D,OAA/B,IAA0CxB,YAAY,MAAM,CAACH,qBAAqB,GAAGlG,UAAU,CAAChC,QAApC,KAAiD,IAAjD,GAAwD,KAAK,CAA7D,GAAiEkI,qBAAqB,CAACpH,KAA7F,CAA1D,EAA+J;MAC7J;MACA,MAAM3D,KAAK,GAAGiL,SAAS,CAAC7K,QAAV,CAAmBE,WAAnB,CAA+B6F,OAA/B,CAAuC4C,QAAvC,CAAd;MACA,IAAI/I,KAAK,GAAG,CAAC,CAAb,EAAgBiL,SAAS,CAAC7K,QAAV,CAAmBE,WAAnB,CAA+BqM,MAA/B,CAAsC3M,KAAtC,EAA6C,CAA7C,EAH6I,CAG5F;;MAEjE,IAAI6E,UAAU,CAAChC,QAAX,CAAoBc,KAAxB,EAA+BsH,SAAS,CAAC7K,QAAV,CAAmBE,WAAnB,CAA+BsD,IAA/B,CAAoCmF,QAApC;IAChC,CAtFiC,CAsFhC;;;IAGF,IAAIf,OAAO,CAAC1D,MAAR,IAAkB,CAAC0G,gBAAgB,GAAGjC,QAAQ,CAACnG,KAA7B,KAAuC,IAAzD,IAAiEoI,gBAAgB,CAACnH,MAAtF,EAA8F+I,cAAc,CAAC7D,QAAD,CAAd;IAC9F,OAAOA,QAAP;EACD;;EAED,SAAS0D,kBAAT,CAA4B1D,QAA5B,EAAsC;IACpC,IAAI8D,gBAAJ,EAAsBC,qBAAtB;;IAEA,MAAM1L,KAAK,GAAG,CAACyL,gBAAgB,GAAG9D,QAAQ,CAACnG,KAA7B,KAAuC,IAAvC,GAA8C,KAAK,CAAnD,GAAuD,CAACkK,qBAAqB,GAAGD,gBAAgB,CAACtE,IAA1C,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmEuE,qBAAqB,CAACzM,QAAtB,IAAkC,IAAlC,GAAyC,KAAK,CAA9C,GAAkDyM,qBAAqB,CAACzM,QAAtB,EAA1L;IACA,IAAIe,KAAK,IAAIA,KAAK,CAAChB,QAAN,CAAe2M,MAAf,KAA0B,CAAvC,EAA0C3L,KAAK,CAAC4L,UAAN;EAC3C;;EAED,SAASJ,cAAT,CAAwB7D,QAAxB,EAAkC;IAChCA,QAAQ,CAACkE,QAAT,IAAqB,IAArB,GAA4B,KAAK,CAAjC,GAAqClE,QAAQ,CAACkE,QAAT,CAAkBlE,QAAlB,CAArC;EACD;;EAED,SAASmE,cAAT,CAAwBC,IAAxB,SAGG5E,IAHH,EAGS6E,WAHT,EAGsBC,sBAHtB,EAG8C;IAAA,IAHhB;MAC5B5C,IAAI,GAAG,EADqB;MAE5B,GAAGf;IAFyB,CAGgB;IAC5C,IAAIhH,IAAI,GAAI,GAAEyK,IAAI,CAAC,CAAD,CAAJ,CAAQG,WAAR,EAAsB,GAAEH,IAAI,CAACjH,KAAL,CAAW,CAAX,CAAc,EAApD;IACA,IAAI6C,QAAJ,CAF4C,CAE9B;IACd;IACA;;IAEA,IAAI,CAACd,OAAO,CAACM,IAAD,CAAR,IAAkB8E,sBAAtB,EAA8C;MAC5C,MAAME,EAAE,GAAGC,IAAI,IAAI;QACjB,IAAI,CAACA,IAAI,CAACC,MAAV,EAAkB,OAAOD,IAAI,CAACE,SAAL,IAAkBF,IAAI,CAACE,SAAL,CAAeC,aAAxC,CAAlB,KAA6E,OAAOJ,EAAE,CAACC,IAAI,CAACC,MAAN,CAAT;MAC9E,CAFD;;MAIAlF,IAAI,GAAGgF,EAAE,CAACF,sBAAD,CAAT;IACD,CAZ2C,CAY1C;;;IAGF,IAAI,CAAC9E,IAAD,IAAS,CAACN,OAAO,CAACM,IAAD,CAArB,EAA6B,MAAO,qBAAoB7F,IAAK,GAAhC;;IAE7B,IAAIyK,IAAI,KAAK,WAAb,EAA0B;MACxB,IAAIzD,KAAK,CAAC5J,MAAN,KAAiBoH,SAArB,EAAgC,MAAO,0CAAP;MAChC,MAAMpH,MAAM,GAAG4J,KAAK,CAAC5J,MAArB;MACAiJ,QAAQ,GAAGD,OAAO,CAAChJ,MAAD,EAAS;QACzByI,IADyB;QAEzBS,SAAS,EAAE;MAFc,CAAT,CAAlB;IAID,CAPD,MAOO;MACL,MAAMpE,MAAM,GAAG+D,SAAS,CAACjG,IAAD,CAAT,IAAmB3E,KAAK,CAAC2E,IAAD,CAAvC;MACA,IAAI,CAACkC,MAAL,EAAa,MAAO,GAAElC,IAAK,mLAAd,CAFR,CAE0M;MAC/M;;MAEAqG,QAAQ,GAAGD,OAAO,CAAC,IAAIlE,MAAJ,CAAW,GAAG6F,IAAd,CAAD,EAAsB;QACtClC,IADsC;QAEtCU,aAAa,EAAE;UACbwB,IAAI,EAAEA,IAAI,CAACnG,MAAL,KAAgB,CAAhB,GAAoB,IAApB,GAA2BmG;QADpB;MAFuB,CAAtB,CAAlB;IAMD,CAnC2C,CAmC1C;;;IAGF,IAAI,EAAE,eAAef,KAAjB,CAAJ,EAA6B;MAC3B,IAAIhH,IAAI,CAACkL,QAAL,CAAc,UAAd,CAAJ,EAA+B;QAC7BlE,KAAK,GAAG;UACNgB,MAAM,EAAE,UADF;UAEN,GAAGhB;QAFG,CAAR;MAID,CALD,MAKO,IAAIhH,IAAI,CAACkL,QAAL,CAAc,UAAd,CAAJ,EAA+B;QACpClE,KAAK,GAAG;UACNgB,MAAM,EAAE,UADF;UAEN,GAAGhB;QAFG,CAAR;MAID;IACF,CAlD2C,CAkD1C;IACF;IACA;;;IAGAiB,UAAU,CAAC5B,QAAD,EAAWW,KAAX,CAAV;IACA,OAAOX,QAAP;EACD;;EAED,SAAS8E,WAAT,CAAqBC,cAArB,EAAqC1F,KAArC,EAA4C;IAC1C,IAAI2F,YAAY,GAAG,KAAnB;;IAEA,IAAI3F,KAAJ,EAAW;MACT;MACA,IAAIA,KAAK,CAAC4F,WAAV,EAAuB;QACrB,IAAI,CAAClP,EAAE,CAACG,GAAH,CAAO6O,cAAc,CAAC1F,KAAK,CAAC4F,WAAP,CAArB,CAAL,EAAgDF,cAAc,CAAC1F,KAAK,CAAC4F,WAAP,CAAd,GAAoC,EAApC;QAChDF,cAAc,CAAC1F,KAAK,CAAC4F,WAAP,CAAd,CAAkCpK,IAAlC,CAAuCwE,KAAvC;MACD,CAHD,MAGO,IAAIA,KAAK,CAAC6F,YAAV,EAAwB;QAC7B,IAAI,CAACnP,EAAE,CAACC,GAAH,CAAO+O,cAAc,CAAC1F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,CAAD,CAArB,CAAL,EAAoDH,cAAc,CAAC1F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,CAAD,CAAd,GAAwC,EAAxC;QACpDH,cAAc,CAAC1F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,CAAD,CAAd,CAAsC7F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,CAAtC,IAA+D7F,KAA/D;MACD,CAHM,MAGA,IAAIA,KAAK,CAACsC,MAAN,IAAgB,CAAC5L,EAAE,CAACI,GAAH,CAAOkJ,KAAK,CAACsC,MAAb,CAArB,EAA2C;QAChDoD,cAAc,CAAC1F,KAAK,CAACsC,MAAP,CAAd,GAA+BtC,KAA/B;MACD,CAFM,MAEA,IAAItJ,EAAE,CAACG,GAAH,CAAOmJ,KAAK,CAAC8F,SAAb,CAAJ,EAA6B;QAClC,MAAM,CAACC,QAAD,IAAa/F,KAAK,CAAC8F,SAAzB;;QAEA,IAAIpP,EAAE,CAACK,GAAH,CAAOgP,QAAP,KAAoBrP,EAAE,CAACI,GAAH,CAAO4O,cAAc,CAACK,QAAD,CAArB,CAAxB,EAA0D;UACxDL,cAAc,CAACK,QAAD,CAAd,CAAyB/F,KAAzB;QACD,CAFD,MAEO,IAAItJ,EAAE,CAACI,GAAH,CAAOiP,QAAP,CAAJ,EAAsB;UAC3BA,QAAQ,CAAC/F,KAAD,EAAQ0F,cAAR,CAAR;QACD;MACF,CARM,MAQA,IAAI1F,KAAK,CAACgG,UAAN,IAAoBN,cAAc,CAACM,UAAvC,EAAmD;QACxD;QACAN,cAAc,CAACrK,GAAf,CAAmB2E,KAAnB;QACA2F,YAAY,GAAG,IAAf;MACD;;MAED,IAAI,CAACA,YAAL,EAAmB;QACjB;QACA;QACAD,cAAc,CAAClL,KAAf,CAAqBJ,OAArB,CAA6BoB,IAA7B,CAAkCwE,KAAlC;MACD;;MAED,IAAI,CAACA,KAAK,CAACxF,KAAX,EAAkB;QAChBkG,OAAO,CAACV,KAAD,EAAQ,EAAR,CAAP;MACD;;MAEDA,KAAK,CAACxF,KAAN,CAAYiB,MAAZ,GAAqBiK,cAArB;MACAlB,cAAc,CAACxE,KAAD,CAAd;MACAqE,kBAAkB,CAACrE,KAAD,CAAlB;IACD;EACF;;EAED,SAASiG,YAAT,CAAsBP,cAAtB,EAAsC1F,KAAtC,EAA6CkG,WAA7C,EAA0D;IACxD,IAAIC,KAAK,GAAG,KAAZ;;IAEA,IAAInG,KAAJ,EAAW;MACT,IAAIA,KAAK,CAAC4F,WAAV,EAAuB;QACrB,MAAMQ,KAAK,GAAGV,cAAc,CAAC1F,KAAK,CAAC4F,WAAP,CAA5B;QACA,IAAI,CAAClP,EAAE,CAACG,GAAH,CAAOuP,KAAP,CAAL,EAAoBV,cAAc,CAAC1F,KAAK,CAAC4F,WAAP,CAAd,GAAoC,EAApC;QACpBQ,KAAK,CAAC7B,MAAN,CAAa6B,KAAK,CAACrI,OAAN,CAAcmI,WAAd,CAAb,EAAyC,CAAzC,EAA4ClG,KAA5C;MACD,CAJD,MAIO,IAAIA,KAAK,CAAC6F,YAAN,IAAsB7F,KAAK,CAACsC,MAAN,IAAgB,CAAC5L,EAAE,CAACI,GAAH,CAAOkJ,KAAK,CAACsC,MAAb,CAA3C,EAAiE;QACtE;QACA,OAAOmD,WAAW,CAACC,cAAD,EAAiB1F,KAAjB,CAAlB;MACD,CAHM,MAGA,IAAIA,KAAK,CAACgG,UAAN,IAAoBN,cAAc,CAACM,UAAvC,EAAmD;QACxDhG,KAAK,CAACvE,MAAN,GAAeiK,cAAf;QACA1F,KAAK,CAACqG,aAAN,CAAoB;UAClBtB,IAAI,EAAE;QADY,CAApB;QAGA,MAAMuB,YAAY,GAAGZ,cAAc,CAACzE,QAAf,CAAwB9I,MAAxB,CAA+BoO,OAAO,IAAIA,OAAO,KAAKvG,KAAtD,CAArB;QACA,MAAMpI,KAAK,GAAG0O,YAAY,CAACvI,OAAb,CAAqBmI,WAArB,CAAd;QACAR,cAAc,CAACzE,QAAf,GAA0B,CAAC,GAAGqF,YAAY,CAACxI,KAAb,CAAmB,CAAnB,EAAsBlG,KAAtB,CAAJ,EAAkCoI,KAAlC,EAAyC,GAAGsG,YAAY,CAACxI,KAAb,CAAmBlG,KAAnB,CAA5C,CAA1B;QACAuO,KAAK,GAAG,IAAR;MACD;;MAED,IAAI,CAACA,KAAL,EAAY;QACVT,cAAc,CAAClL,KAAf,CAAqBJ,OAArB,CAA6BoB,IAA7B,CAAkCwE,KAAlC;MACD;;MAED,IAAI,CAACA,KAAK,CAACxF,KAAX,EAAkB;QAChBkG,OAAO,CAACV,KAAD,EAAQ,EAAR,CAAP;MACD;;MAEDA,KAAK,CAACxF,KAAN,CAAYiB,MAAZ,GAAqBiK,cAArB;MACAlB,cAAc,CAACxE,KAAD,CAAd;MACAqE,kBAAkB,CAACrE,KAAD,CAAlB;IACD;EACF;;EAED,SAASwG,eAAT,CAAyBJ,KAAzB,EAAgC3K,MAAhC,EAAyD;IAAA,IAAjB+H,OAAiB,uEAAP,KAAO;IACvD,IAAI4C,KAAJ,EAAW,CAAC,GAAGA,KAAJ,EAAW7N,OAAX,CAAmByH,KAAK,IAAIyG,WAAW,CAAChL,MAAD,EAASuE,KAAT,EAAgBwD,OAAhB,CAAvC;EACZ;;EAED,SAASiD,WAAT,CAAqBf,cAArB,EAAqC1F,KAArC,EAA4CwD,OAA5C,EAAqD;IACnD,IAAIxD,KAAJ,EAAW;MACT,IAAI0G,qBAAJ,EAA2BC,aAA3B;;MAEA,IAAI3G,KAAK,CAACxF,KAAV,EAAiB;QACfwF,KAAK,CAACxF,KAAN,CAAYiB,MAAZ,GAAqB,IAArB;MACD;;MAED,IAAI,CAACiL,qBAAqB,GAAGhB,cAAc,CAAClL,KAAxC,KAAkD,IAAlD,IAA0DkM,qBAAqB,CAACtM,OAApF,EAA6F;QAC3FsL,cAAc,CAAClL,KAAf,CAAqBJ,OAArB,GAA+BsL,cAAc,CAAClL,KAAf,CAAqBJ,OAArB,CAA6BjC,MAA7B,CAAoCiE,CAAC,IAAIA,CAAC,KAAK4D,KAA/C,CAA/B;MACD,CATQ,CASP;;;MAGF,IAAIA,KAAK,CAAC4F,WAAV,EAAuB;QACrBF,cAAc,CAAC1F,KAAK,CAAC4F,WAAP,CAAd,GAAoCF,cAAc,CAAC1F,KAAK,CAAC4F,WAAP,CAAd,CAAkCzN,MAAlC,CAAyCiE,CAAC,IAAIA,CAAC,KAAK4D,KAApD,CAApC;MACD,CAFD,MAEO,IAAIA,KAAK,CAAC6F,YAAV,EAAwB;QAC7B,OAAOH,cAAc,CAAC1F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,CAAD,CAAd,CAAsC7F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,CAAtC,CAAP;MACD,CAFM,MAEA,IAAI7F,KAAK,CAACsC,MAAN,IAAgB,CAAC5L,EAAE,CAACI,GAAH,CAAOkJ,KAAK,CAACsC,MAAb,CAArB,EAA2C;QAChDoD,cAAc,CAAC1F,KAAK,CAACsC,MAAP,CAAd,GAA+B,IAA/B;MACD,CAFM,MAEA,IAAI5L,EAAE,CAACG,GAAH,CAAOmJ,KAAK,CAAC8F,SAAb,CAAJ,EAA6B;QAClC,MAAM,GAAGc,QAAH,IAAe5G,KAAK,CAAC8F,SAA3B;;QAEA,IAAIpP,EAAE,CAACK,GAAH,CAAO6P,QAAP,KAAoBlQ,EAAE,CAACI,GAAH,CAAO4O,cAAc,CAACkB,QAAD,CAArB,CAAxB,EAA0D;UACxDlB,cAAc,CAACkB,QAAD,CAAd,CAAyB5G,KAAzB;QACD,CAFD,MAEO,IAAItJ,EAAE,CAACI,GAAH,CAAO8P,QAAP,CAAJ,EAAsB;UAC3BA,QAAQ,CAAC5G,KAAD,EAAQ0F,cAAR,CAAR;QACD;MACF,CARM,MAQA,IAAI1F,KAAK,CAACgG,UAAV,EAAsB;QAC3B,IAAIa,YAAJ;;QAEAnB,cAAc,CAACoB,MAAf,CAAsB9G,KAAtB,EAH2B,CAGG;;QAE9B,IAAI,CAAC6G,YAAY,GAAG7G,KAAK,CAACxF,KAAtB,KAAgC,IAAhC,IAAwCqM,YAAY,CAAC1G,IAAzD,EAA+D;UAC7DrI,mBAAmB,CAACkI,KAAK,CAACxF,KAAN,CAAY2F,IAAb,EAAmBH,KAAnB,CAAnB;QACD;MACF,CAlCQ,CAkCP;MACF;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;;MAGA,MAAM+G,WAAW,GAAG,CAACJ,aAAa,GAAG3G,KAAK,CAACxF,KAAvB,KAAiC,IAAjC,GAAwC,KAAK,CAA7C,GAAiDmM,aAAa,CAAC/F,SAAnF;MACA,MAAMoG,aAAa,GAAGxD,OAAO,KAAK1E,SAAZ,GAAwBkB,KAAK,CAACwD,OAAN,KAAkB,IAAlB,IAA0B,CAACuD,WAAnD,GAAiEvD,OAAvF,CA9CS,CA8CuF;MAChG;;MAEA,IAAI,CAACuD,WAAL,EAAkB;QAChB,IAAIE,aAAJ;;QAEAT,eAAe,CAAC,CAACS,aAAa,GAAGjH,KAAK,CAACxF,KAAvB,KAAiC,IAAjC,GAAwC,KAAK,CAA7C,GAAiDyM,aAAa,CAAC7M,OAAhE,EAAyE4F,KAAzE,EAAgFgH,aAAhF,CAAf;QACAR,eAAe,CAACxG,KAAK,CAACiB,QAAP,EAAiBjB,KAAjB,EAAwBgH,aAAxB,CAAf;MACD,CAtDQ,CAsDP;;;MAGF,IAAIhH,KAAK,CAACxF,KAAV,EAAiB;QACf,OAAOwF,KAAK,CAACxF,KAAN,CAAY2F,IAAnB;QACA,OAAOH,KAAK,CAACxF,KAAN,CAAYJ,OAAnB;QACA,OAAO4F,KAAK,CAACxF,KAAN,CAAYC,QAAnB;QACA,OAAOuF,KAAK,CAACxF,KAAN,CAAYqG,aAAnB;QACA,IAAI,CAACkG,WAAL,EAAkB,OAAO/G,KAAK,CAACxF,KAAb;MACnB,CA/DQ,CA+DP;;;MAGF,IAAIwM,aAAa,IAAIhH,KAAK,CAACwD,OAAvB,IAAkCxD,KAAK,CAAC+E,IAAN,KAAe,OAArD,EAA8D;QAC5D9O,wBAAwB,CAACC,qBAAD,EAAwB,MAAM;UACpD,IAAI;YACF8J,KAAK,CAACwD,OAAN;UACD,CAFD,CAEE,OAAO0D,CAAP,EAAU;YACV;UACD;QACF,CANuB,CAAxB;MAOD;;MAED7C,kBAAkB,CAACqB,cAAD,CAAlB;IACD;EACF;;EAED,SAASyB,cAAT,CAAwBxG,QAAxB,EAAkCoE,IAAlC,EAAwCqC,QAAxC,EAAkDC,KAAlD,EAAyD;IACvD,IAAIC,gBAAJ;;IAEA,MAAM7L,MAAM,GAAG,CAAC6L,gBAAgB,GAAG3G,QAAQ,CAACnG,KAA7B,KAAuC,IAAvC,GAA8C,KAAK,CAAnD,GAAuD8M,gBAAgB,CAAC7L,MAAvF;IACA,IAAI,CAACA,MAAL,EAAa;IACb,MAAM8L,WAAW,GAAGzC,cAAc,CAACC,IAAD,EAAOqC,QAAP,EAAiBzG,QAAQ,CAACnG,KAAT,CAAe2F,IAAhC,CAAlC,CALuD,CAKkB;IACzE;IACA;IACA;;IAEA,IAAI4E,IAAI,KAAK,WAAT,IAAwBpE,QAAQ,CAACM,QAArC,EAA+C;MAC7CN,QAAQ,CAACM,QAAT,CAAkB1I,OAAlB,CAA0ByH,KAAK,IAAIyF,WAAW,CAAC8B,WAAD,EAAcvH,KAAd,CAA9C;MACAW,QAAQ,CAACM,QAAT,GAAoB,EAApB;IACD;;IAEDN,QAAQ,CAACnG,KAAT,CAAeJ,OAAf,CAAuB7B,OAAvB,CAA+ByH,KAAK,IAAIyF,WAAW,CAAC8B,WAAD,EAAcvH,KAAd,CAAnD;;IAEAW,QAAQ,CAACnG,KAAT,CAAeJ,OAAf,GAAyB,EAAzB;IACAqM,WAAW,CAAChL,MAAD,EAASkF,QAAT,CAAX;IACA8E,WAAW,CAAChK,MAAD,EAAS8L,WAAT,CAAX,CAAiC;IACjC;IACA;IAFA;IAIA,CAACF,KAAD,EAAQA,KAAK,CAACG,SAAd,EAAyBjP,OAAzB,CAAiC8O,KAAK,IAAI;MACxC,IAAIA,KAAK,KAAK,IAAd,EAAoB;QAClBA,KAAK,CAAC/B,SAAN,GAAkBiC,WAAlB;;QAEA,IAAIF,KAAK,CAACjG,GAAV,EAAe;UACb,IAAI,OAAOiG,KAAK,CAACjG,GAAb,KAAqB,UAAzB,EAAqCiG,KAAK,CAACjG,GAAN,CAAUmG,WAAV,EAArC,KAAiEF,KAAK,CAACjG,GAAN,CAAUqG,OAAV,GAAoBF,WAApB;QAClE;MACF;IACF,CARD;EASD;;EAED,MAAMG,UAAU,GAAG3R,UAAU,CAAC;IAC5B4R,GAAG,EAAE3R,YADuB;IAE5B8O,cAF4B;IAG5B2B,WAH4B;IAI5BhB,WAJ4B;IAK5BmC,kBAAkB,EAAEnC,WALQ;IAM5BQ,YAN4B;IAO5B4B,gBAAgB,EAAE,IAPU;IAQ5BC,gBAAgB,EAAE,IARU;IAS5BC,iBAAiB,EAAE,KATS;IAU5B;IACAC,eAAe,EAAEtR,EAAE,CAACI,GAAH,CAAOmR,UAAP,IAAqBA,UAArB,GAAkCnJ,SAXvB;IAY5B;IACAoJ,aAAa,EAAExR,EAAE,CAACI,GAAH,CAAOqR,YAAP,IAAuBA,YAAvB,GAAsCrJ,SAbzB;IAc5B;IACAmJ,UAAU,EAAEvR,EAAE,CAACI,GAAH,CAAOmR,UAAP,IAAqBA,UAArB,GAAkCnJ,SAflB;IAgB5B;IACAqJ,YAAY,EAAEzR,EAAE,CAACI,GAAH,CAAOqR,YAAP,IAAuBA,YAAvB,GAAsCrJ,SAjBxB;IAkB5BsJ,SAAS,EAAE,CAAC,CAlBgB;IAmB5BC,sBAAsB,EAAE,CAAC3C,cAAD,EAAiB1F,KAAjB,KAA2B;MACjD,MAAM;QACJD,SADI;QAEJI;MAFI,IAGFL,YAAY,CAAC4F,cAAD,EAAiB1F,KAAjB,CAHhB,CADiD,CAIR;;MAEzCD,SAAS,CAACvF,KAAV,CAAgB2F,IAAhB,GAAuBA,IAAvB;MACAsF,WAAW,CAAC1F,SAAD,EAAYC,KAAZ,CAAX;IACD,CA3B2B;IA4B5BsI,wBAAwB,EAAE,CAAC5C,cAAD,EAAiB1F,KAAjB,KAA2ByG,WAAW,CAAC3G,YAAY,CAAC4F,cAAD,EAAiB1F,KAAjB,CAAZ,CAAoCD,SAArC,EAAgDC,KAAhD,CA5BpC;IA6B5BuI,uBAAuB,EAAE,CAAC7C,cAAD,EAAiB1F,KAAjB,EAAwBkG,WAAxB,KAAwCD,YAAY,CAACnG,YAAY,CAAC4F,cAAD,EAAiB1F,KAAjB,CAAZ,CAAoCD,SAArC,EAAgDC,KAAhD,EAAuDkG,WAAvD,CA7BjD;;IA+B5BsC,aAAa,CAAC7H,QAAD,EAAWoE,IAAX,EAAiB0D,QAAjB,EAA2BrB,QAA3B,EAAqC;MAChD,IAAIzG,QAAQ,CAACnG,KAAT,CAAeoG,SAAf,IAA4BwG,QAAQ,CAAC1P,MAArC,IAA+C0P,QAAQ,CAAC1P,MAAT,KAAoBiJ,QAAvE,EAAiF,OAAO,CAAC,IAAD,CAAP,CAAjF,KAAoG;QAClG;QACA,MAAM;UACJ0B,IAAI,EAAEqG,OAAO,GAAG,EADZ;UAEJzH,QAAQ,EAAEC,EAFN;UAGJ,GAAGyH;QAHC,IAIFvB,QAJJ;QAKA,MAAM;UACJ/E,IAAI,EAAEuG,OAAO,GAAG,EADZ;UAEJ3H,QAAQ,EAAE4H,EAFN;UAGJ,GAAGC;QAHC,IAIFL,QAJJ,CAPkG,CAWpF;;QAEd,IAAIC,OAAO,CAACrO,IAAR,CAAa,CAAC7B,KAAD,EAAQZ,KAAR,KAAkBY,KAAK,KAAKoQ,OAAO,CAAChR,KAAD,CAAhD,CAAJ,EAA8D,OAAO,CAAC,IAAD,CAAP,CAboC,CAarB;;QAE7E,MAAMmR,IAAI,GAAG/H,SAAS,CAACL,QAAD,EAAWgI,OAAX,EAAoBG,OAApB,EAA6B,IAA7B,CAAtB;QACA,IAAIC,IAAI,CAACnJ,OAAL,CAAa1D,MAAjB,EAAyB,OAAO,CAAC,KAAD,EAAQ6M,IAAR,CAAP,CAhByE,CAgBnD;;QAE/C,OAAO,IAAP;MACD;IACF,CApD2B;;IAsD5BC,YAAY,CAACrI,QAAD,SAAgCoE,IAAhC,EAAsC0D,QAAtC,EAAgDrB,QAAhD,EAA0DC,KAA1D,EAAiE;MAAA,IAAtD,CAAC4B,WAAD,EAAcF,IAAd,CAAsD;MAC3E;MACA,IAAIE,WAAJ,EAAiB9B,cAAc,CAACxG,QAAD,EAAWoE,IAAX,EAAiBqC,QAAjB,EAA2BC,KAA3B,CAAd,CAAjB,CAAkE;MAAlE,KACK9E,UAAU,CAAC5B,QAAD,EAAWoI,IAAX,CAAV;IACN,CA1D2B;;IA4D5BG,YAAY,CAACvI,QAAD,EAAW;MACrB,IAAIA,QAAQ,CAACqF,UAAb,EAAyB;QACvBrF,QAAQ,CAACwI,OAAT,GAAmB,KAAnB;QACA9E,kBAAkB,CAAC1D,QAAD,CAAlB;MACD;IACF,CAjE2B;;IAmE5ByI,cAAc,CAACzI,QAAD,EAAWW,KAAX,EAAkB;MAC9B,IAAIX,QAAQ,CAACqF,UAAT,IAAuB1E,KAAK,CAAC6H,OAAN,IAAiB,IAAxC,IAAgD7H,KAAK,CAAC6H,OAA1D,EAAmE;QACjExI,QAAQ,CAACwI,OAAT,GAAmB,IAAnB;QACA9E,kBAAkB,CAAC1D,QAAD,CAAlB;MACD;IACF,CAxE2B;;IA0E5B0I,gBAAgB,GAAG;MACjB,MAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;IACD,CA5E2B;;IA8E5BC,iBAAiB,CAAC5I,QAAD,EAAW;MAC1B;MACA,OAAOA,QAAP;IACD,CAjF2B;;IAmF5B6I,kBAAkB,CAACC,aAAD,EAAgB;MAChC,OAAOnJ,KAAP;IACD,CArF2B;;IAuF5BoJ,mBAAmB,CAACC,iBAAD,EAAoB;MACrC,OAAOA,iBAAP;IACD,CAzF2B;;IA2F5BC,kBAAkB,GAAG,CAAE,CA3FK;;IA6F5BC,uBAAuB,GAAG;MACxB,OAAO,KAAP;IACD,CA/F2B;;IAiG5BC,WAAW,GAAG,CAAC;IACd,CAlG2B;;IAoG5BC,yBAAyB,GAAG;MAC1B,OAAO,KAAP;IACD,CAtG2B;;IAwG5BC,gBAAgB,GAAG;MACjB,OAAO,IAAP;IACD,CA1G2B;;IA4G5BC,kBAAkB,CAAC1E,aAAD,EAAgB;MAChC7E,OAAO,CAAC6E,aAAD,CAAP;IACD,CA9G2B;;IAgH5B2E,gBAAgB,GAAG,CAAC;IACnB,CAjH2B;;IAmH5BC,oBAAoB,GAAG;MACrB,OAAO,KAAP;IACD,CArH2B;;IAuH5BC,cAAc,GAAG;MACf,OAAO,KAAP;IACD;;EAzH2B,CAAD,CAA7B;EA4HA,OAAO;IACL1C,UADK;IAELnF;EAFK,CAAP;AAID;;AAED,MAAM8H,UAAU,GAAG3K,GAAG,IAAI,CAAC,EAAEA,GAAG,IAAI,IAAP,IAAeA,GAAG,CAAC4K,MAArB,CAA3B;;AACA,MAAMC,oBAAoB,GAAG7K,GAAG,IAAIA,GAAG,IAAIA,GAAG,CAAC6K,oBAA/C;;AACA,SAASC,YAAT,CAAsBC,GAAtB,EAA2B;EACzB,OAAOvT,KAAK,CAACC,OAAN,CAAcsT,GAAd,IAAqBzQ,IAAI,CAAC0Q,GAAL,CAAS1Q,IAAI,CAAC2Q,GAAL,CAASF,GAAG,CAAC,CAAD,CAAZ,EAAiBG,MAAM,CAACC,gBAAxB,CAAT,EAAoDJ,GAAG,CAAC,CAAD,CAAvD,CAArB,GAAmFA,GAA1F;AACD;;AACD,MAAMK,OAAO,GAAG,aAAalV,KAAK,CAACmV,aAAN,CAAoB,IAApB,CAA7B;;AAEA,MAAMC,WAAW,GAAG,CAACzI,UAAD,EAAaqC,UAAb,EAAyBqG,OAAzB,EAAkC3J,KAAlC,KAA4C;EAC9D,MAAM;IACJ4J,EADI;IAEJ9R,IAFI;IAGJ+R,OAAO,GAAG,KAHN;IAIJnH,MAAM,GAAG,KAJL;IAKJoH,IAAI,GAAG,KALH;IAMJC,EAAE,GAAG,KAND;IAOJC,YAAY,GAAG,KAPX;IAQJC,SAAS,GAAG,QARR;IASJd,GAAG,GAAG,CATF;IAUJe,WAVI;IAWJC,KAAK,GAAG,IAAI9V,KAAK,CAAC+V,KAAV,EAXJ;IAYJzS,SAAS,EAAE0S,cAZP;IAaJxS,MAAM,EAAEyS,aAbJ;IAcJjN;EAdI,IAeF2C,KAfJ,CAD8D,CAgBnD;;EAEX,IAAI6J,OAAJ,EAAa;IACXD,EAAE,CAACW,SAAH,CAAalR,OAAb,GAAuB,IAAvB;IACA,IAAI,OAAOwQ,OAAP,KAAmB,QAAvB,EAAiC5U,MAAM,CAACuV,MAAP,CAAcZ,EAAE,CAACW,SAAjB,EAA4BV,OAA5B,EAAjC,KAA2ED,EAAE,CAACW,SAAH,CAAa9G,IAAb,GAAoBpP,KAAK,CAACoW,gBAA1B;EAC5E,CArB6D,CAqB5D;;;EAGF,IAAI,CAAC/H,MAAL,EAAakH,EAAE,CAACc,cAAH,GAAoBrW,KAAK,CAACyO,YAA1B;EACb,IAAI,CAACgH,IAAL,EAAWF,EAAE,CAACe,WAAH,GAAiBtW,KAAK,CAACuW,qBAAvB,CAzBmD,CAyBL;;EAEzD,IAAIX,SAAS,KAAK,OAAlB,EAA2B;IACzBE,KAAK,CAACU,IAAN;IACAV,KAAK,CAACW,WAAN,GAAoB,CAApB;EACD;;EAED,MAAMvJ,SAAS,GAAGhN,MAAM,CAAC,CAAC6D,GAAD,EAAMmC,GAAN,KAAc;IACrC;IACA,MAAM5C,SAAS,GAAG,IAAItD,KAAK,CAAC0W,SAAV,EAAlB;IACA,MAAM;MACJC,MADI;MAEJ,GAAGC;IAFC,IAGFZ,cAAc,IAAI,EAHtB;IAIApJ,UAAU,CAACtJ,SAAD,EAAY;MACpB0B,OAAO,EAAE,IADW;MAEpB,GAAG4R,OAFiB;MAGpBD,MAAM,EAAE,EAAE,GAAGrT,SAAS,CAACqT,MAAf;QACN,GAAGA;MADG;IAHY,CAAZ,CAAV,CAPqC,CAajC;;IAEJ,MAAME,QAAQ,GAAGZ,aAAa,YAAYjW,KAAK,CAAC8W,MAAhD;IACA,MAAMtT,MAAM,GAAGqT,QAAQ,GAAGZ,aAAH,GAAmBN,YAAY,GAAG,IAAI3V,KAAK,CAAC+W,kBAAV,CAA6B,CAA7B,EAAgC,CAAhC,EAAmC,CAAnC,EAAsC,CAAtC,EAAyC,GAAzC,EAA8C,IAA9C,CAAH,GAAyD,IAAI/W,KAAK,CAACgX,iBAAV,CAA4B,EAA5B,EAAgC,CAAhC,EAAmC,GAAnC,EAAwC,IAAxC,CAA/G;;IAEA,IAAI,CAACH,QAAL,EAAe;MACbrT,MAAM,CAACyT,QAAP,CAAgBC,CAAhB,GAAoB,CAApB;MACA,IAAIjB,aAAJ,EAAmBrJ,UAAU,CAACpJ,MAAD,EAASyS,aAAT,CAAV,CAFN,CAEyC;;MAEtD,IAAI,EAAEA,aAAa,IAAI,IAAjB,IAAyBA,aAAa,CAACkB,QAAzC,CAAJ,EAAwD3T,MAAM,CAAC4T,MAAP,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB;IACzD;;IAED,MAAMC,UAAU,GAAGxC,YAAY,CAACC,GAAD,CAA/B;IACA,MAAMmC,QAAQ,GAAG,IAAIjX,KAAK,CAACkD,OAAV,EAAjB;IACA,MAAMoU,aAAa,GAAG,IAAItX,KAAK,CAACkD,OAAV,EAAtB;IACA,MAAMqU,UAAU,GAAG,IAAIvX,KAAK,CAACkD,OAAV,EAAnB;;IAEA,SAASsU,kBAAT,GAA8F;MAAA,IAAlEhU,MAAkE,uEAAzD0C,GAAG,GAAG1C,MAAmD;MAAA,IAA3CqD,MAA2C,uEAAlCyQ,aAAkC;MAAA,IAAnB7T,IAAmB,uEAAZyC,GAAG,GAAGzC,IAAM;MAC5F,MAAM;QACJI,KADI;QAEJC;MAFI,IAGFL,IAHJ;MAIA,MAAMgU,MAAM,GAAG5T,KAAK,GAAGC,MAAvB;MACA,IAAI+C,MAAM,YAAY7G,KAAK,CAACkD,OAA5B,EAAqCqU,UAAU,CAACzJ,IAAX,CAAgBjH,MAAhB,EAArC,KAAkE0Q,UAAU,CAACxT,GAAX,CAAe,GAAG8C,MAAlB;MAClE,MAAM6Q,QAAQ,GAAGlU,MAAM,CAACmU,gBAAP,CAAwBV,QAAxB,EAAkCW,UAAlC,CAA6CL,UAA7C,CAAjB;;MAEA,IAAI3C,oBAAoB,CAACpR,MAAD,CAAxB,EAAkC;QAChC,OAAO;UACLK,KAAK,EAAEA,KAAK,GAAGL,MAAM,CAACqU,IADjB;UAEL/T,MAAM,EAAEA,MAAM,GAAGN,MAAM,CAACqU,IAFnB;UAGLC,MAAM,EAAE,CAHH;UAILJ,QAJK;UAKLD;QALK,CAAP;MAOD,CARD,MAQO;QACL,MAAMM,GAAG,GAAGvU,MAAM,CAACuU,GAAP,GAAa1T,IAAI,CAAC2T,EAAlB,GAAuB,GAAnC,CADK,CACmC;;QAExC,MAAMC,CAAC,GAAG,IAAI5T,IAAI,CAAC6T,GAAL,CAASH,GAAG,GAAG,CAAf,CAAJ,GAAwBL,QAAlC,CAHK,CAGuC;;QAE5C,MAAMS,CAAC,GAAGF,CAAC,IAAIpU,KAAK,GAAGC,MAAZ,CAAX;QACA,OAAO;UACLD,KAAK,EAAEsU,CADF;UAELrU,MAAM,EAAEmU,CAFH;UAGLH,MAAM,EAAEjU,KAAK,GAAGsU,CAHX;UAILT,QAJK;UAKLD;QALK,CAAP;MAOD;IACF;;IAED,IAAIW,kBAAkB,GAAGjP,SAAzB;;IAEA,MAAMkP,qBAAqB,GAAGvG,OAAO,IAAI/N,GAAG,CAACV,KAAK,KAAK;MACrDwS,WAAW,EAAE,EAAE,GAAGxS,KAAK,CAACwS,WAAX;QACX/D;MADW;IADwC,CAAL,CAAN,CAA5C;;IAMA,OAAO;MACLyD,EADK;MAELxR,GAFK;MAGLmC,GAHK;MAIL+I,UAAU,EAAE,MAAMA,UAAU,CAAC/I,GAAG,EAAJ,CAJvB;MAKLoP,OAAO,EAAE,CAACgD,SAAD,EAAYC,gBAAZ,KAAiCjD,OAAO,CAACgD,SAAD,EAAYC,gBAAZ,EAA8BrS,GAAG,EAAjC,CAL5C;MAMLmI,MANK;MAOLoH,IAPK;MAQLhL,KAAK,EAAEM,OAAO,CAAC,IAAI/K,KAAK,CAACwY,KAAV,EAAD,CART;MASLhV,MATK;MAULiV,QAAQ,EAAE,IAVL;MAWLnV,SAXK;MAYLwS,KAZK;MAaLvS,KAAK,EAAE,IAAIvD,KAAK,CAAC0Y,OAAV,EAbF;MAcLhD,EAdK;MAeLE,SAfK;MAgBL5M,eAhBK;MAiBL6M,WAAW,EAAE;QACX/D,OAAO,EAAE,CADE;QAEXiD,GAAG,EAAE,GAFM;QAGXC,GAAG,EAAE,CAHM;QAIX2D,QAAQ,EAAE,GAJC;QAKX,GAAG9C,WALQ;QAMX+C,OAAO,EAAE,MAAM;UACb,MAAMvV,KAAK,GAAG6C,GAAG,EAAjB,CADa,CACQ;;UAErB,IAAIkS,kBAAJ,EAAwB5F,YAAY,CAAC4F,kBAAD,CAAZ,CAHX,CAG6C;;UAE1D,IAAI/U,KAAK,CAACwS,WAAN,CAAkB/D,OAAlB,KAA8BzO,KAAK,CAACwS,WAAN,CAAkBd,GAApD,EAAyDsD,qBAAqB,CAAChV,KAAK,CAACwS,WAAN,CAAkBd,GAAnB,CAArB,CAL5C,CAK0F;;UAEvGqD,kBAAkB,GAAG9F,UAAU,CAAC,MAAM+F,qBAAqB,CAACnS,GAAG,GAAG2P,WAAN,CAAkBb,GAAnB,CAA5B,EAAqD3R,KAAK,CAACwS,WAAN,CAAkB8C,QAAvE,CAA/B;QACD;MAdU,CAjBR;MAiCLlV,IAAI,EAAE;QACJI,KAAK,EAAE,CADH;QAEJC,MAAM,EAAE;MAFJ,CAjCD;MAqCL+U,QAAQ,EAAE;QACRxB,UADQ;QAERvC,GAAG,EAAEuC,UAFG;QAGRxT,KAAK,EAAE,CAHC;QAIRC,MAAM,EAAE,CAJA;QAKR2T,MAAM,EAAE,CALA;QAMRC,QAAQ,EAAE,CANF;QAORI,MAAM,EAAE,CAPA;QAQRN;MARQ,CArCL;MA+CLsB,OAAO,EAAE,CAACjV,KAAD,EAAQC,MAAR,KAAmB;QAC1B,MAAML,IAAI,GAAG;UACXI,KADW;UAEXC;QAFW,CAAb;QAIAC,GAAG,CAACV,KAAK,KAAK;UACZI,IADY;UAEZoV,QAAQ,EAAE,EAAE,GAAGxV,KAAK,CAACwV,QAAX;YACR,GAAGrB,kBAAkB,CAAChU,MAAD,EAAS8T,aAAT,EAAwB7T,IAAxB;UADb;QAFE,CAAL,CAAN,CAAH;MAMD,CA1DI;MA2DLsV,MAAM,EAAEjE,GAAG,IAAI/Q,GAAG,CAACV,KAAK,KAAK;QAC3BwV,QAAQ,EAAE,EAAE,GAAGxV,KAAK,CAACwV,QAAX;UACR/D,GAAG,EAAED,YAAY,CAACC,GAAD;QADT;MADiB,CAAL,CAAN,CA3Db;MAgELkE,MAAM,EAAE;QACNC,SAAS,EAAE;MADL,CAhEH;MAmEL5W,QAAQ,EAAE;QACR6W,MAAM,EAAE,KADA;QAERC,QAAQ,EAAE,CAFF;QAGRnK,MAAM,EAAE,CAHA;QAIRoK,SAAS,EAAEzN,KAJH;QAKRpJ,WAAW,EAAE,EALL;QAMRI,OAAO,EAAE,IAAI0E,GAAJ,EAND;QAORgS,WAAW,EAAE,EAPL;QAQRlV,YAAY,EAAE,CAAC,CAAD,EAAI,CAAJ,CARN;QASRzB,WAAW,EAAE,EATL;QAURsD,WAAW,EAAE,IAAIqB,GAAJ,EAVL;QAWRiS,SAAS,EAAE,UAAC7N,GAAD,EAAuB;UAAA,IAAjB0N,QAAiB,uEAAN,CAAM;UAChCpV,GAAG,CAAC;YAAA,IAAC;cACH1B;YADG,CAAD;YAAA,OAEG;cACLA,QAAQ,EAAE,EAAE,GAAGA,QAAL;gBACR;gBACA;gBACA;gBACA;gBACA8W,QAAQ,EAAE9W,QAAQ,CAAC8W,QAAT,IAAqBA,QAAQ,GAAG,CAAX,GAAe,CAAf,GAAmB,CAAxC,CALF;gBAMR;gBACA;gBACAE,WAAW,EAAE,CAAC,GAAGhX,QAAQ,CAACgX,WAAb,EAA0B;kBACrC5N,GADqC;kBAErC0N;gBAFqC,CAA1B,EAGVI,IAHU,CAGL,CAACtY,CAAD,EAAIS,CAAJ,KAAUT,CAAC,CAACkY,QAAF,GAAazX,CAAC,CAACyX,QAHpB;cARL;YADL,CAFH;UAAA,CAAD,CAAH;UAiBA,OAAO,MAAM;YACXpV,GAAG,CAAC;cAAA,IAAC;gBACH1B;cADG,CAAD;cAAA,OAEG;gBACLA,QAAQ,EAAE,EAAE,GAAGA,QAAL;kBACR;kBACA8W,QAAQ,EAAE9W,QAAQ,CAAC8W,QAAT,IAAqBA,QAAQ,GAAG,CAAX,GAAe,CAAf,GAAmB,CAAxC,CAFF;kBAGR;kBACAE,WAAW,EAAEhX,QAAQ,CAACgX,WAAT,CAAqB7W,MAArB,CAA4BgX,CAAC,IAAIA,CAAC,CAAC/N,GAAF,KAAUA,GAA3C;gBAJL;cADL,CAFH;YAAA,CAAD,CAAH;UAUD,CAXD;QAYD;MAzCO;IAnEL,CAAP;EA+GD,CAtLuB,CAAxB,CAhC8D,CAsN1D;;EAEJyB,SAAS,CAACoM,SAAV,CAAoB,MAAM;IACxB,MAAM;MACJ9V,MADI;MAEJC,IAFI;MAGJoV,QAHI;MAIJxW;IAJI,IAKF6K,SAAS,CAAC5K,QAAV,EALJ,CADwB,CAME;IAC1B;;IAEA,IAAI,EAAED,QAAQ,CAAC+W,SAAT,CAAmB5V,MAAnB,YAAqCxD,KAAK,CAAC8W,MAA7C,CAAJ,EAA0D;MACxD,IAAIlC,oBAAoB,CAACpR,MAAD,CAAxB,EAAkC;QAChCA,MAAM,CAACiW,IAAP,GAAchW,IAAI,CAACI,KAAL,GAAa,CAAC,CAA5B;QACAL,MAAM,CAACkW,KAAP,GAAejW,IAAI,CAACI,KAAL,GAAa,CAA5B;QACAL,MAAM,CAACmW,GAAP,GAAalW,IAAI,CAACK,MAAL,GAAc,CAA3B;QACAN,MAAM,CAACoW,MAAP,GAAgBnW,IAAI,CAACK,MAAL,GAAc,CAAC,CAA/B;MACD,CALD,MAKO;QACLN,MAAM,CAACiU,MAAP,GAAgBhU,IAAI,CAACI,KAAL,GAAaJ,IAAI,CAACK,MAAlC;MACD;;MAEDN,MAAM,CAACqW,sBAAP,GAVwD,CAUvB;MACjC;;MAEArW,MAAM,CAACsW,iBAAP;IACD,CAvBuB,CAuBtB;;;IAGFvE,EAAE,CAACwE,aAAH,CAAiBlB,QAAQ,CAAC/D,GAA1B;IACAS,EAAE,CAACuD,OAAH,CAAWrV,IAAI,CAACI,KAAhB,EAAuBJ,IAAI,CAACK,MAA5B;EACD,CA5BD,EA4BGT,KAAK,IAAI,CAACA,KAAK,CAACwV,QAAN,CAAe/D,GAAhB,EAAqBzR,KAAK,CAACI,IAA3B,CA5BZ,EA4B8CtD,OA5B9C;EA6BA,MAAMkD,KAAK,GAAG6J,SAAS,CAAC5K,QAAV,EAAd,CArP8D,CAqP1B;;EAEpC,IAAImB,IAAJ,EAAUJ,KAAK,CAACyV,OAAN,CAAcrV,IAAI,CAACI,KAAnB,EAA0BJ,IAAI,CAACK,MAA/B,EAvPoD,CAuPZ;;EAElDoJ,SAAS,CAACoM,SAAV,CAAoBjW,KAAK,IAAI4L,UAAU,CAAC5L,KAAD,CAAvC,EAzP8D,CAyPb;;EAEjD,OAAO6J,SAAP;AACD,CA5PD;;AA8PA,SAAS8M,UAAT,CAAoB1T,QAApB,EAA8B2T,IAA9B,EAAoC;EAClC,MAAMhY,KAAK,GAAGgY,IAAI,CAAC1T,MAAnB;EACA0T,IAAI,CAACpU,IAAL,CAAUS,QAAV;EACA,OAAO,MAAM,KAAK2T,IAAI,CAACrL,MAAL,CAAY3M,KAAZ,EAAmB,CAAnB,CAAlB;AACD;;AAED,IAAIN,CAAJ;AACA,IAAIuY,aAAa,GAAG,EAApB;AACA,IAAIC,kBAAkB,GAAG,EAAzB;AACA,IAAIC,iBAAiB,GAAG,EAAxB;;AACA,MAAMC,SAAS,GAAG/T,QAAQ,IAAI0T,UAAU,CAAC1T,QAAD,EAAW4T,aAAX,CAAxC;;AACA,MAAMI,cAAc,GAAGhU,QAAQ,IAAI0T,UAAU,CAAC1T,QAAD,EAAW6T,kBAAX,CAA7C;;AACA,MAAMI,OAAO,GAAGjU,QAAQ,IAAI0T,UAAU,CAAC1T,QAAD,EAAW8T,iBAAX,CAAtC;;AAEA,SAASI,GAAT,CAAaC,OAAb,EAAsBnC,SAAtB,EAAiC;EAC/B,KAAK3W,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG8Y,OAAO,CAAClU,MAAxB,EAAgC5E,CAAC,EAAjC,EAAqC8Y,OAAO,CAAC9Y,CAAD,CAAP,CAAW2W,SAAX;AACtC;;AAED,SAASoC,QAAT,CAAkBpC,SAAlB,EAA6BjV,KAA7B,EAAoC;EAClC;EACA,IAAIgD,KAAK,GAAGhD,KAAK,CAACyS,KAAN,CAAY6E,QAAZ,EAAZ,CAFkC,CAEE;;EAEpC,IAAItX,KAAK,CAACuS,SAAN,KAAoB,OAApB,IAA+B,OAAO0C,SAAP,KAAqB,QAAxD,EAAkE;IAChEjS,KAAK,GAAGiS,SAAS,GAAGjV,KAAK,CAACyS,KAAN,CAAYW,WAAhC;IACApT,KAAK,CAACyS,KAAN,CAAY8E,OAAZ,GAAsBvX,KAAK,CAACyS,KAAN,CAAYW,WAAlC;IACApT,KAAK,CAACyS,KAAN,CAAYW,WAAZ,GAA0B6B,SAA1B;EACD,CARiC,CAQhC;;;EAGF,KAAK3W,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,KAAK,CAAChB,QAAN,CAAegX,WAAf,CAA2B9S,MAA3C,EAAmD5E,CAAC,EAApD,EAAwD0B,KAAK,CAAChB,QAAN,CAAegX,WAAf,CAA2B1X,CAA3B,EAA8B8J,GAA9B,CAAkCqG,OAAlC,CAA0CzO,KAA1C,EAAiDgD,KAAjD,EAXtB,CAW+E;;;EAGjH,IAAI,CAAChD,KAAK,CAAChB,QAAN,CAAe8W,QAAhB,IAA4B9V,KAAK,CAACkS,EAAN,CAASZ,MAAzC,EAAiDtR,KAAK,CAACkS,EAAN,CAASZ,MAAT,CAAgBtR,KAAK,CAACoH,KAAtB,EAA6BpH,KAAK,CAACG,MAAnC,EAdf,CAc2D;;EAE7FH,KAAK,CAAChB,QAAN,CAAe2M,MAAf,GAAwB3K,IAAI,CAAC2Q,GAAL,CAAS,CAAT,EAAY3R,KAAK,CAAChB,QAAN,CAAe2M,MAAf,GAAwB,CAApC,CAAxB;EACA,OAAO3L,KAAK,CAACuS,SAAN,KAAoB,QAApB,GAA+B,CAA/B,GAAmCvS,KAAK,CAAChB,QAAN,CAAe2M,MAAzD;AACD;;AAED,SAAS6L,UAAT,CAAoBzP,KAApB,EAA2B;EACzB,IAAI0P,OAAO,GAAG,KAAd;EACA,IAAIC,MAAJ;;EAEA,SAASC,IAAT,CAAc1C,SAAd,EAAyB;IACvBwC,OAAO,GAAG,IAAV;IACAC,MAAM,GAAG,CAAT,CAFuB,CAEX;;IAEZP,GAAG,CAACN,aAAD,EAAgB5B,SAAhB,CAAH,CAJuB,CAIQ;;IAE/BlN,KAAK,CAACxI,OAAN,CAAc4H,IAAI,IAAI;MACpB,MAAMnH,KAAK,GAAGmH,IAAI,CAACpI,KAAL,CAAWE,QAAX,EAAd,CADoB,CACiB;;MAErC,IAAIe,KAAK,CAAChB,QAAN,CAAe6W,MAAf,KAA0B7V,KAAK,CAACuS,SAAN,KAAoB,QAApB,IAAgCvS,KAAK,CAAChB,QAAN,CAAe2M,MAAf,GAAwB,CAAlF,CAAJ,EAA0F+L,MAAM,IAAIL,QAAQ,CAACpC,SAAD,EAAYjV,KAAZ,CAAlB;IAC3F,CAJD,EANuB,CAUnB;;IAEJmX,GAAG,CAACL,kBAAD,EAAqB7B,SAArB,CAAH,CAZuB,CAYa;;IAEpC,IAAIyC,MAAM,GAAG,CAAb,EAAgB,OAAOE,qBAAqB,CAACD,IAAD,CAA5B,CAAhB,CAAoD;IAApD,KACKR,GAAG,CAACJ,iBAAD,EAAoB9B,SAApB,CAAH,CAfkB,CAeiB;;IAExCwC,OAAO,GAAG,KAAV;EACD;;EAED,SAAS7L,UAAT,CAAoB5L,KAApB,EAA2B;IACzB,IAAI,CAACA,KAAL,EAAY,OAAO+H,KAAK,CAACxI,OAAN,CAAc4H,IAAI,IAAIyE,UAAU,CAACzE,IAAI,CAACpI,KAAL,CAAWE,QAAX,EAAD,CAAhC,CAAP;IACZ,IAAIe,KAAK,CAACqS,EAAN,IAAY,CAACrS,KAAK,CAAChB,QAAN,CAAe6W,MAA5B,IAAsC7V,KAAK,CAACuS,SAAN,KAAoB,OAA9D,EAAuE,OAF9C,CAEsD;;IAE/EvS,KAAK,CAAChB,QAAN,CAAe2M,MAAf,GAAwB3K,IAAI,CAAC0Q,GAAL,CAAS,EAAT,EAAa1R,KAAK,CAAChB,QAAN,CAAe2M,MAAf,GAAwB,CAArC,CAAxB,CAJyB,CAIwC;;IAEjE,IAAI,CAAC8L,OAAL,EAAc;MACZA,OAAO,GAAG,IAAV;MACAG,qBAAqB,CAACD,IAAD,CAArB;IACD;EACF;;EAED,SAAS1F,OAAT,CAAiBgD,SAAjB,EAA4D;IAAA,IAAhCC,gBAAgC,uEAAb,IAAa;IAAA,IAAPlV,KAAO;IAC1D,IAAIkV,gBAAJ,EAAsBiC,GAAG,CAACN,aAAD,EAAgB5B,SAAhB,CAAH;IACtB,IAAI,CAACjV,KAAL,EAAY+H,KAAK,CAACxI,OAAN,CAAc4H,IAAI,IAAIkQ,QAAQ,CAACpC,SAAD,EAAY9N,IAAI,CAACpI,KAAL,CAAWE,QAAX,EAAZ,CAA9B,EAAZ,KAAmFoY,QAAQ,CAACpC,SAAD,EAAYjV,KAAZ,CAAR;IACnF,IAAIkV,gBAAJ,EAAsBiC,GAAG,CAACL,kBAAD,EAAqB7B,SAArB,CAAH;EACvB;;EAED,OAAO;IACL0C,IADK;IAEL/L,UAFK;IAGLqG;EAHK,CAAP;AAKD;;AAED,SAAS4F,mBAAT,CAA6B9Y,KAA7B,EAAoC;EAClC,MAAM;IACJ2G;EADI,IAEF/F,YAAY,CAACZ,KAAD,CAFhB;EAGA,MAAM+Y,KAAK,GAAG;IACZC,OAAO,EAAE,CAAC,OAAD,EAAU,KAAV,CADG;IAEZC,aAAa,EAAE,CAAC,aAAD,EAAgB,KAAhB,CAFH;IAGZC,aAAa,EAAE,CAAC,UAAD,EAAa,KAAb,CAHH;IAIZC,OAAO,EAAE,CAAC,OAAD,EAAU,IAAV,CAJG;IAKZC,aAAa,EAAE,CAAC,aAAD,EAAgB,IAAhB,CALH;IAMZC,WAAW,EAAE,CAAC,WAAD,EAAc,IAAd,CAND;IAOZ3S,cAAc,EAAE,CAAC,cAAD,EAAiB,IAAjB,CAPJ;IAQZY,aAAa,EAAE,CAAC,aAAD,EAAgB,IAAhB,CARH;IASZgS,eAAe,EAAE,CAAC,eAAD,EAAkB,IAAlB,CATL;IAUZC,oBAAoB,EAAE,CAAC,oBAAD,EAAuB,IAAvB;EAVV,CAAd;EAYA,OAAO;IACL1C,SAAS,EAAE,KADN;IAELnU,QAAQ,EAAElE,MAAM,CAACwL,IAAP,CAAY+O,KAAZ,EAAmB5N,MAAnB,CAA0B,CAACC,GAAD,EAAM1K,GAAN,MAAe,EAAE,GAAG0K,GAAL;MACjD,CAAC1K,GAAD,GAAOiG,aAAa,CAACjG,GAAD;IAD6B,CAAf,CAA1B,EAEN,EAFM,CAFL;IAKL8Y,OAAO,EAAE/U,MAAM,IAAI;MACjB,IAAIgV,gBAAJ;;MAEA,MAAM;QACJ9X,GADI;QAEJiV;MAFI,IAGF5W,KAAK,CAACE,QAAN,EAHJ;MAIA0W,MAAM,CAAC8C,UAAP,IAAqB,IAArB,GAA4B,KAAK,CAAjC,GAAqC9C,MAAM,CAAC8C,UAAP,EAArC;MACA/X,GAAG,CAACV,KAAK,KAAK;QACZ2V,MAAM,EAAE,EAAE,GAAG3V,KAAK,CAAC2V,MAAX;UACNC,SAAS,EAAEpS;QADL;MADI,CAAL,CAAN,CAAH;MAKAjG,MAAM,CAACsL,OAAP,CAAe,CAAC2P,gBAAgB,GAAG7C,MAAM,IAAI,IAAV,GAAiB,KAAK,CAAtB,GAA0BA,MAAM,CAAClU,QAArD,KAAkE,IAAlE,GAAyE+W,gBAAzE,GAA4F,EAA3G,EAA+GjZ,OAA/G,CAAuH,SAAmB;QAAA,IAAlB,CAAC+B,IAAD,EAAO9C,KAAP,CAAkB;QACxI,MAAM,CAACka,SAAD,EAAYC,OAAZ,IAAuBb,KAAK,CAACxW,IAAD,CAAlC;QACAkC,MAAM,CAACoV,gBAAP,CAAwBF,SAAxB,EAAmCla,KAAnC,EAA0C;UACxCma;QADwC,CAA1C;MAGD,CALD;IAMD,CAxBI;IAyBLF,UAAU,EAAE,MAAM;MAChB,MAAM;QACJ/X,GADI;QAEJiV;MAFI,IAGF5W,KAAK,CAACE,QAAN,EAHJ;;MAKA,IAAI0W,MAAM,CAACC,SAAX,EAAsB;QACpB,IAAIiD,iBAAJ;;QAEAtb,MAAM,CAACsL,OAAP,CAAe,CAACgQ,iBAAiB,GAAGlD,MAAM,CAAClU,QAA5B,KAAyC,IAAzC,GAAgDoX,iBAAhD,GAAoE,EAAnF,EAAuFtZ,OAAvF,CAA+F,UAAmB;UAAA,IAAlB,CAAC+B,IAAD,EAAO9C,KAAP,CAAkB;;UAChH,IAAImX,MAAM,IAAIA,MAAM,CAACC,SAAP,YAA4BkD,WAA1C,EAAuD;YACrD,MAAM,CAACJ,SAAD,IAAcZ,KAAK,CAACxW,IAAD,CAAzB;YACAqU,MAAM,CAACC,SAAP,CAAiBmD,mBAAjB,CAAqCL,SAArC,EAAgDla,KAAhD;UACD;QACF,CALD;QAMAkC,GAAG,CAACV,KAAK,KAAK;UACZ2V,MAAM,EAAE,EAAE,GAAG3V,KAAK,CAAC2V,MAAX;YACNC,SAAS,EAAE;UADL;QADI,CAAL,CAAN,CAAH;MAKD;IACF;EA9CI,CAAP;AAgDD,C,CAED;AACA;AACA;;;AACA,MAAMoD,yBAAyB,GAAG,OAAOpH,MAAP,KAAkB,WAAlB,GAAgChV,KAAK,CAACqc,eAAtC,GAAwDrc,KAAK,CAACsc,SAAhG;;AAEA,SAASC,KAAT,SAEG;EAAA,IAFY;IACbzY;EADa,CAEZ;EACDsY,yBAAyB,CAAC,MAAM;IAC9BtY,GAAG,CAAC,IAAI0Y,OAAJ,CAAY,MAAM,IAAlB,CAAD,CAAH;IACA,OAAO,MAAM1Y,GAAG,CAAC,KAAD,CAAhB;EACD,CAHwB,EAGtB,EAHsB,CAAzB;EAIA,OAAO,IAAP;AACD;;AAED,MAAM2Y,aAAN,SAA4Bzc,KAAK,CAAC0c,SAAlC,CAA4C;EAC1ChP,WAAW,GAAU;IACnB,MAAM,YAAN;IACA,KAAKtK,KAAL,GAAa;MACXuZ,KAAK,EAAE;IADI,CAAb;EAGD;;EAEDC,iBAAiB,CAACD,KAAD,EAAQ;IACvB,KAAKjR,KAAL,CAAW5H,GAAX,CAAe6Y,KAAf;EACD;;EAEDjI,MAAM,GAAG;IACP,OAAO,KAAKtR,KAAL,CAAWuZ,KAAX,GAAmB,IAAnB,GAA0B,KAAKjR,KAAL,CAAWL,QAA5C;EACD;;AAdyC;;AAkB5CoR,aAAa,CAACI,wBAAd,GAAyC,OAAO;EAC9CF,KAAK,EAAE;AADuC,CAAP,CAAzC;;AAIA,MAAMG,MAAM,GAAG,aAAa9c,KAAK,CAAC+c,UAAN,CAAiB,SAASD,MAAT,SAU1CE,YAV0C,EAU5B;EAAA,IAV4C;IAC3D3R,QAD2D;IAE3D4R,QAF2D;IAG3DC,QAH2D;IAI3DC,MAJ2D;IAK3D5X,EAL2D;IAM3D6X,KAN2D;IAO3DC,SAP2D;IAQ3DtE,MAR2D;IAS3D,GAAGrN;EATwD,CAU5C;EACf,MAAM,CAAC4R,YAAD,EAAe;IACnB1Z,KADmB;IAEnBC;EAFmB,CAAf,IAGDpD,UAAU,CAAC;IACd8c,MAAM,EAAE,IADM;IAEd7E,QAAQ,EAAE;MACR6E,MAAM,EAAE,EADA;MAERJ,MAAM,EAAE;IAFA,CAFI;IAMd,GAAGA;EANW,CAAD,CAHf;EAWA,MAAMK,SAAS,GAAGxd,KAAK,CAACyd,MAAN,CAAa,IAAb,CAAlB;EACA,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoB3d,KAAK,CAAC4d,QAAN,CAAe,KAAf,CAA1B;EACA,MAAM,CAACjB,KAAD,EAAQkB,QAAR,IAAoB7d,KAAK,CAAC4d,QAAN,CAAe,KAAf,CAA1B,CAde,CAckC;;EAEjD,IAAIF,KAAJ,EAAW,MAAMA,KAAN,CAhBI,CAgBS;;EAExB,IAAIf,KAAJ,EAAW,MAAMA,KAAN,CAlBI,CAkBS;;EAExBP,yBAAyB,CAAC,MAAM;IAC9B,IAAIxY,KAAK,GAAG,CAAR,IAAaC,MAAM,GAAG,CAA1B,EAA6B;MAC3B6Q,MAAM,EAAE,aAAa1U,KAAK,CAAC8d,aAAN,CAAoBrB,aAApB,EAAmC;QACtD3Y,GAAG,EAAE+Z;MADiD,CAAnC,EAElB,aAAa7d,KAAK,CAAC8d,aAAN,CAAoB9d,KAAK,CAAC+d,QAA1B,EAAoC;QAClDd,QAAQ,EAAE,aAAajd,KAAK,CAAC8d,aAAN,CAAoBvB,KAApB,EAA2B;UAChDzY,GAAG,EAAE6Z;QAD2C,CAA3B;MAD2B,CAApC,EAIbtS,QAJa,CAFK,CAAf,EAMSmS,SAAS,CAAC3L,OANnB,EAM4B,EAAE,GAAGnG,KAAL;QAChClI,IAAI,EAAE;UACJI,KADI;UAEJC;QAFI,CAD0B;QAKhCkV,MAAM,EAAEA,MAAM,IAAIkC;MALc,CAN5B,CAAN;IAaD;EACF,CAhBwB,EAgBtB,CAACrX,KAAD,EAAQC,MAAR,EAAgBwH,QAAhB,CAhBsB,CAAzB;EAiBA+Q,yBAAyB,CAAC,MAAM;IAC9B,MAAMjS,SAAS,GAAGqT,SAAS,CAAC3L,OAA5B;IACA,OAAO,MAAMmM,sBAAsB,CAAC7T,SAAD,CAAnC;EACD,CAHwB,EAGtB,EAHsB,CAAzB;EAIA,OAAO,aAAanK,KAAK,CAAC8d,aAAN,CAAoB,KAApB,EAA2B;IAC7CtS,GAAG,EAAE8R,YADwC;IAE7C/X,EAAE,EAAEA,EAFyC;IAG7C8X,SAAS,EAAEA,SAHkC;IAI7CH,QAAQ,EAAEA,QAJmC;IAK7CE,KAAK,EAAE;MACLpG,QAAQ,EAAE,UADL;MAELpT,KAAK,EAAE,MAFF;MAGLC,MAAM,EAAE,MAHH;MAILoa,QAAQ,EAAE,QAJL;MAKL,GAAGb;IALE;EALsC,CAA3B,EAYjB,aAAapd,KAAK,CAAC8d,aAAN,CAAoB,QAApB,EAA8B;IAC5CtS,GAAG,EAAEhL,SAAS,CAAC,CAACgd,SAAD,EAAYR,YAAZ,CAAD,CAD8B;IAE5CI,KAAK,EAAE;MACLc,OAAO,EAAE;IADJ;EAFqC,CAA9B,EAKbjB,QALa,CAZI,CAApB;AAkBD,CArE2B,CAA5B;;AAuEA,SAASkB,QAAT,GAAoB;EAClB,MAAMhc,KAAK,GAAGnC,KAAK,CAACoe,UAAN,CAAiBlJ,OAAjB,CAAd;EACA,IAAI,CAAC/S,KAAL,EAAY,MAAO,yDAAP;EACZ,OAAOA,KAAP;AACD;;AACD,SAASkc,QAAT,GAAyD;EAAA,IAAvCC,QAAuC,uEAA5Blb,KAAK,IAAIA,KAAmB;EAAA,IAAZmb,UAAY;EACvD,OAAOJ,QAAQ,GAAGG,QAAH,EAAaC,UAAb,CAAf;AACD;;AACD,SAASC,QAAT,CAAkBnY,QAAlB,EAAgD;EAAA,IAApBoY,cAAoB,uEAAH,CAAG;EAC9C,MAAMpF,SAAS,GAAG8E,QAAQ,GAAG9b,QAAX,GAAsBD,QAAtB,CAA+BiX,SAAjD,CAD8C,CACc;;EAE5D,MAAM7N,GAAG,GAAGxL,KAAK,CAACyd,MAAN,CAAapX,QAAb,CAAZ;EACArG,KAAK,CAACqc,eAAN,CAAsB,MAAM,MAAM7Q,GAAG,CAACqG,OAAJ,GAAcxL,QAApB,CAA5B,EAA2D,CAACA,QAAD,CAA3D,EAJ8C,CAI0B;;EAExErG,KAAK,CAACqc,eAAN,CAAsB,MAAMhD,SAAS,CAAC7N,GAAD,EAAMiT,cAAN,CAArC,EAA4D,CAACA,cAAD,EAAiBpF,SAAjB,CAA5D;EACA,OAAO,IAAP;AACD;;AAED,SAASqF,UAAT,CAAoB5c,MAApB,EAA4B;EAC1B,MAAM6G,IAAI,GAAG;IACXgW,KAAK,EAAE,EADI;IAEXC,SAAS,EAAE;EAFA,CAAb;;EAKA,IAAI9c,MAAJ,EAAY;IACVA,MAAM,CAAC+c,QAAP,CAAgB9d,GAAG,IAAI;MACrB,IAAIA,GAAG,CAAC2D,IAAR,EAAc;QACZiE,IAAI,CAACgW,KAAL,CAAW5d,GAAG,CAAC2D,IAAf,IAAuB3D,GAAvB;MACD;;MAED,IAAIA,GAAG,CAAC+d,QAAJ,IAAgB,CAACnW,IAAI,CAACiW,SAAL,CAAe7d,GAAG,CAAC+d,QAAJ,CAAapa,IAA5B,CAArB,EAAwD;QACtDiE,IAAI,CAACiW,SAAL,CAAe7d,GAAG,CAAC+d,QAAJ,CAAapa,IAA5B,IAAoC3D,GAAG,CAAC+d,QAAxC;MACD;IACF,CARD;EASD;;EAED,OAAOnW,IAAP;AACD;;AAED,SAASoW,QAAT,CAAkBjd,MAAlB,EAA0B;EACxB,OAAO9B,KAAK,CAACgf,OAAN,CAAc,MAAMN,UAAU,CAAC5c,MAAD,CAA9B,EAAwC,CAACA,MAAD,CAAxC,CAAP;AACD;;AAED,SAASmd,SAAT,CAAmBC,UAAnB,EAA+BC,UAA/B,EAA2C;EACzC,OAAO,UAAUC,KAAV,EAA2B;IAChC;IACA,MAAMC,MAAM,GAAG,IAAID,KAAJ,EAAf;IACA,IAAIF,UAAJ,EAAgBA,UAAU,CAACG,MAAD,CAAV,CAHgB,CAGI;;IAHJ,kCAAPC,KAAO;MAAPA,KAAO;IAAA;;IAKhC,OAAO9C,OAAO,CAAC+C,GAAR,CAAYD,KAAK,CAACnW,GAAN,CAAUmW,KAAK,IAAI,IAAI9C,OAAJ,CAAY,CAACgD,GAAD,EAAMC,MAAN,KAAiBJ,MAAM,CAACK,IAAP,CAAYJ,KAAZ,EAAmB3W,IAAI,IAAI;MAC5F,IAAIA,IAAI,CAAC6B,KAAT,EAAgB7J,MAAM,CAACuV,MAAP,CAAcvN,IAAd,EAAoB+V,UAAU,CAAC/V,IAAI,CAAC6B,KAAN,CAA9B;MAChBgV,GAAG,CAAC7W,IAAD,CAAH;IACD,CAHkE,EAGhEwW,UAHgE,EAGpDxC,KAAK,IAAI8C,MAAM,CAAE,kBAAiBH,KAAM,KAAI3C,KAAK,CAACgD,OAAQ,EAA3C,CAHqC,CAA7B,CAAnB,CAAZ,CAAP;EAID,CATD;AAUD;;AAED,SAASC,SAAT,CAAmBR,KAAnB,EAA0BE,KAA1B,EAAiCJ,UAAjC,EAA6CC,UAA7C,EAAyD;EACvD;EACA,MAAMhT,IAAI,GAAG7K,KAAK,CAACC,OAAN,CAAc+d,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAA5C;EACA,MAAMO,OAAO,GAAGtf,QAAQ,CAAC0e,SAAS,CAACC,UAAD,EAAaC,UAAb,CAAV,EAAoCC,KAApC,EAA2C,GAAGjT,IAA9C,CAAxB,CAHuD,CAGsB;;EAE7E,OAAO7K,KAAK,CAACC,OAAN,CAAc+d,KAAd,IAAuBO,OAAvB,GAAiCA,OAAO,CAAC,CAAD,CAA/C;AACD;;AAEDD,SAAS,CAACE,OAAV,GAAoB,UAAUV,KAAV,EAAiBE,KAAjB,EAAwBJ,UAAxB,EAAoC;EACtD,MAAM/S,IAAI,GAAG7K,KAAK,CAACC,OAAN,CAAc+d,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAA5C;EACA,OAAO/e,QAAQ,CAACuf,OAAT,CAAiBb,SAAS,CAACC,UAAD,CAA1B,EAAwCE,KAAxC,EAA+C,GAAGjT,IAAlD,CAAP;AACD,CAHD;;AAKAyT,SAAS,CAACG,KAAV,GAAkB,UAAUX,KAAV,EAAiBE,KAAjB,EAAwB;EACxC,MAAMnT,IAAI,GAAG7K,KAAK,CAACC,OAAN,CAAc+d,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAA5C;EACA,OAAO/e,QAAQ,CAACwf,KAAT,CAAeX,KAAf,EAAsB,GAAGjT,IAAzB,CAAP;AACD,CAHD;;AAKA,MAAMhB,KAAK,GAAG,IAAI/D,GAAJ,EAAd;AACA,MAAM4Y,KAAK,GAAG,CAAC,QAAD,EAAW,UAAX,EAAuB,YAAvB,CAAd;AACA,MAAM;EACJhR,UADI;EAEJqG;AAFI,IAGFuF,UAAU,CAACzP,KAAD,CAHd;AAIA,MAAM;EACJ2G,UADI;EAEJnF;AAFI,IAGFzB,cAAc,EAHlB;;AAKA,MAAM+U,sBAAsB,GAAG,CAAC3K,EAAD,EAAK4K,MAAL,KAAgB;EAC7C,MAAMC,cAAc,GAAG,OAAO7K,EAAP,KAAc,UAAd,GAA2BA,EAAE,CAAC4K,MAAD,CAA7B,GAAwC5K,EAA/D;EACA,IAAIb,UAAU,CAAC0L,cAAD,CAAd,EAAgC,OAAOA,cAAP;EAChC,MAAMC,QAAQ,GAAG,IAAIrgB,KAAK,CAACsgB,aAAV,CAAwB;IACvCC,eAAe,EAAE,kBADsB;IAEvCJ,MAAM,EAAEA,MAF+B;IAGvCK,SAAS,EAAE,IAH4B;IAIvCC,KAAK,EAAE,IAJgC;IAKvC,GAAGlL;EALoC,CAAxB,CAAjB;EAOA,IAAIA,EAAJ,EAAQ3I,UAAU,CAACyT,QAAD,EAAW9K,EAAX,CAAV;EACR,OAAO8K,QAAP;AACD,CAZD;;AAcA,SAAS1L,MAAT,CAAgB+L,OAAhB,EAAyBP,MAAzB,EAOQ;EAAA,IAPyB;IAC/B5K,EAD+B;IAE/B9R,IAF+B;IAG/Bkd,IAAI,GAAGV,KAAK,CAAC,CAAD,CAHmB;IAI/BjH,MAJ+B;IAK/B4H,SAL+B;IAM/B,GAAGjV;EAN4B,CAOzB,uEAAJ,EAAI;;EACN,IAAIkV,MAAJ,CADM,CAGN;;;EACA,IAAI,CAACpd,IAAL,EAAW;IACT,IAAIqd,qBAAJ,EAA2BC,sBAA3B,EAAmDC,sBAAnD,EAA2EC,sBAA3E;;IAEAxd,IAAI,GAAG;MACLI,KAAK,EAAE,CAACid,qBAAqB,GAAG,CAACC,sBAAsB,GAAGZ,MAAM,CAACe,aAAjC,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmEH,sBAAsB,CAACI,WAAnH,KAAmI,IAAnI,GAA0IL,qBAA1I,GAAkK,CADpK;MAELhd,MAAM,EAAE,CAACkd,sBAAsB,GAAG,CAACC,sBAAsB,GAAGd,MAAM,CAACe,aAAjC,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmED,sBAAsB,CAACG,YAApH,KAAqI,IAArI,GAA4IJ,sBAA5I,GAAqK;IAFxK,CAAP;EAID;;EAED,IAAIxW,IAAI,GAAGY,KAAK,CAAClF,GAAN,CAAUia,MAAV,CAAX;EACA,IAAIzO,KAAK,GAAGlH,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACkH,KAAzC;EACA,IAAItP,KAAK,GAAGoI,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACpI,KAAzC;EACA,IAAIiB,KAAK,GAAG,CAACwd,MAAM,GAAGze,KAAV,KAAoB,IAApB,GAA2B,KAAK,CAAhC,GAAoCye,MAAM,CAACve,QAAP,EAAhD;;EAEA,IAAIoP,KAAK,IAAIrO,KAAb,EAAoB;IAClB;IACA;IACA,IAAIsI,KAAK,CAACmJ,GAAN,KAAc3L,SAAd,IAA2B,CAACpI,EAAE,CAACU,GAAH,CAAO4B,KAAK,CAACwV,QAAN,CAAe/D,GAAtB,EAA2BD,YAAY,CAAClJ,KAAK,CAACmJ,GAAP,CAAvC,CAAhC,EAAqFzR,KAAK,CAAC0V,MAAN,CAAapN,KAAK,CAACmJ,GAAnB,EAHnE,CAG4F;;IAE9G,IAAIzR,KAAK,CAACI,IAAN,CAAWI,KAAX,KAAqBJ,IAAI,CAACI,KAA1B,IAAmCR,KAAK,CAACI,IAAN,CAAWK,MAAX,KAAsBL,IAAI,CAACK,MAAlE,EAA0ET,KAAK,CAACyV,OAAN,CAAcrV,IAAI,CAACI,KAAnB,EAA0BJ,IAAI,CAACK,MAA/B,EALxD,CAKgG;IAClH;;IAEA,MAAMud,aAAa,GAAG1V,KAAK,CAAC0C,MAAN,KAAiBhL,KAAK,CAAChB,QAAN,CAAe+W,SAAf,CAAyB/K,MAAhE;;IAEA,IAAIgT,aAAJ,EAAmB;MACjBpD,sBAAsB,CAACkC,MAAD,CAAtB;MACAzO,KAAK,GAAGvI,SAAR;IACD;EACF;;EAED,IAAI,CAACuI,KAAL,EAAY;IACV;IACA;IACA,MAAM4P,UAAU,GAAGpB,sBAAsB,CAAC3K,EAAD,EAAK4K,MAAL,CAAzC,CAHU,CAG6C;;IAEvD,IAAIxU,KAAK,CAAC+J,EAAV,EAAc;MACZ4L,UAAU,CAACC,EAAX,CAAcvc,OAAd,GAAwB,IAAxB;MACAsc,UAAU,CAACE,gBAAX,CAA4BlJ,SAAS,IAAIhD,OAAO,CAACgD,SAAD,EAAY,IAAZ,CAAhD;IACD,CARS,CAQR;;;IAGFlW,KAAK,GAAGiT,WAAW,CAACzI,UAAD,EAAaqC,UAAb,EAAyBqG,OAAzB,EAAkC;MACnDC,EAAE,EAAE+L,UAD+C;MAEnD7d,IAFmD;MAGnD,GAAGkI;IAHgD,CAAlC,CAAnB;IAKA,MAAMtI,KAAK,GAAGjB,KAAK,CAACE,QAAN,EAAd,CAhBU,CAgBsB;;IAEhCoP,KAAK,GAAGK,UAAU,CAAC0P,eAAX,CAA2Brf,KAA3B,EAAkC6d,KAAK,CAAC7X,OAAN,CAAcuY,IAAd,CAAlC,EAAuD,KAAvD,EAA8D,IAA9D,CAAR,CAlBU,CAkBmE;;IAE7EvV,KAAK,CAACrH,GAAN,CAAUoc,MAAV,EAAkB;MAChBzO,KADgB;MAEhBtP;IAFgB,CAAlB,EApBU,CAuBN;;IAEJ,IAAI4W,MAAJ,EAAY3V,KAAK,CAACU,GAAN,CAAU;MACpBiV,MAAM,EAAEA,MAAM,CAAC5W,KAAD;IADM,CAAV;EAGb;;EAED,IAAIA,KAAK,IAAIsP,KAAb,EAAoB;IAClBK,UAAU,CAAC2P,eAAX,EAA4B,aAAazhB,KAAK,CAAC8d,aAAN,CAAoB4D,QAApB,EAA8B;MACrEvf,KAAK,EAAEA,KAD8D;MAErEse,OAAO,EAAEA,OAF4D;MAGrEE,SAAS,EAAEA,SAH0D;MAIrE/Z,MAAM,EAAEsZ;IAJ6D,CAA9B,CAAzC,EAKIzO,KALJ,EAKW,IALX,EAKiB,MAAMvI,SALvB;IAMA,OAAO/G,KAAP;EACD,CARD,MAQO;IACL,MAAM,sBAAN;EACD;AACF;;AAED,SAASuf,QAAT,SAKG;EAAA,IALe;IAChBvf,KADgB;IAEhBse,OAFgB;IAGhBE,SAHgB;IAIhB/Z;EAJgB,CAKf;EACD5G,KAAK,CAACsc,SAAN,CAAgB,MAAM;IACpB,MAAMlZ,KAAK,GAAGjB,KAAK,CAACE,QAAN,EAAd,CADoB,CACY;;IAEhCe,KAAK,CAACU,GAAN,CAAUV,KAAK,KAAK;MAClBhB,QAAQ,EAAE,EAAE,GAAGgB,KAAK,CAAChB,QAAX;QACR6W,MAAM,EAAE;MADA;IADQ,CAAL,CAAf,EAHoB,CAOf;;IAEL7V,KAAK,CAAC2V,MAAN,CAAa4C,OAAb,IAAwB,IAAxB,GAA+B,KAAK,CAApC,GAAwCvY,KAAK,CAAC2V,MAAN,CAAa4C,OAAb,CAAqB/U,MAArB,CAAxC,CAToB,CASkD;;IAEtE,IAAI+Z,SAAJ,EAAeA,SAAS,CAACvd,KAAD,CAAT;EAChB,CAZD,EAYG,EAZH;EAaA,OAAO,aAAapD,KAAK,CAAC8d,aAAN,CAAoB5I,OAAO,CAACwM,QAA5B,EAAsC;IACxD9e,KAAK,EAAET;EADiD,CAAtC,EAEjBse,OAFiB,CAApB;AAGD;;AAED,SAASzC,sBAAT,CAAgCkC,MAAhC,EAAwC7Z,QAAxC,EAAkD;EAChD,MAAMkE,IAAI,GAAGY,KAAK,CAAClF,GAAN,CAAUia,MAAV,CAAb;EACA,MAAMzO,KAAK,GAAGlH,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACkH,KAA3C;;EAEA,IAAIA,KAAJ,EAAW;IACT,MAAMrO,KAAK,GAAGmH,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACpI,KAAL,CAAWE,QAAX,EAAtC;IACA,IAAIe,KAAJ,EAAWA,KAAK,CAAChB,QAAN,CAAe6W,MAAf,GAAwB,KAAxB;IACXnH,UAAU,CAAC2P,eAAX,CAA2B,IAA3B,EAAiChQ,KAAjC,EAAwC,IAAxC,EAA8C,MAAM;MAClD,IAAIrO,KAAJ,EAAW;QACTiP,UAAU,CAAC,MAAM;UACf,IAAIsP,SAAJ,EAAeC,qBAAf,EAAsCC,UAAtC;;UAEAze,KAAK,CAAC2V,MAAN,CAAa8C,UAAb,IAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2CzY,KAAK,CAAC2V,MAAN,CAAa8C,UAAb,EAA3C;UACA,CAAC8F,SAAS,GAAGve,KAAK,CAACkS,EAAnB,KAA0B,IAA1B,GAAiC,KAAK,CAAtC,GAA0C,CAACsM,qBAAqB,GAAGD,SAAS,CAACG,WAAnC,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmEF,qBAAqB,CAAChU,OAAtB,IAAiC,IAAjC,GAAwC,KAAK,CAA7C,GAAiDgU,qBAAqB,CAAChU,OAAtB,EAA9J;UACA,CAACiU,UAAU,GAAGze,KAAK,CAACkS,EAApB,KAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2CuM,UAAU,CAACE,gBAAX,IAA+B,IAA/B,GAAsC,KAAK,CAA3C,GAA+CF,UAAU,CAACE,gBAAX,EAA1F;UACAnU,OAAO,CAACxK,KAAD,CAAP;UACA+H,KAAK,CAACrI,MAAN,CAAaod,MAAb;UACA,IAAI7Z,QAAJ,EAAcA,QAAQ,CAAC6Z,MAAD,CAAR;QACf,CATS,EASP,GATO,CAAV;MAUD;IACF,CAbD;EAcD;AACF;;AAED,SAAStS,OAAT,CAAiB7M,GAAjB,EAAsB;EACpB,IAAIA,GAAG,CAAC6M,OAAJ,IAAe7M,GAAG,CAACoO,IAAJ,KAAa,OAAhC,EAAyCpO,GAAG,CAAC6M,OAAJ;;EAEzC,KAAK,MAAMoU,CAAX,IAAgBjhB,GAAhB,EAAqB;IACnB,IAAIkhB,QAAJ,EAAcC,IAAd;;IACA,CAACD,QAAQ,GAAG,CAACC,IAAI,GAAGF,CAAR,EAAWpU,OAAvB,KAAmC,IAAnC,GAA0C,KAAK,CAA/C,GAAmDqU,QAAQ,CAACE,IAAT,CAAcD,IAAd,CAAnD;IACA,OAAOnhB,GAAG,CAACihB,CAAD,CAAV;EACD;AACF;;AAED,MAAMI,GAAG,GAAGtQ,UAAU,CAACsQ,GAAvB;;AAEA,SAASC,YAAT,CAAsBhX,QAAtB,EAAgClB,SAAhC,EAA2C;EACzC,OAAO2H,UAAU,CAACuQ,YAAX,CAAwBhX,QAAxB,EAAkClB,SAAlC,EAA6C,IAA7C,EAAmD,IAAnD,CAAP;AACD;;AAED2H,UAAU,CAACwQ,kBAAX,CAA8B;EAC5BC,UAAU,EAAEC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC,CAAxC,GAA4C,CAD5B;EAE5BC,mBAAmB,EAAE,oBAFO;EAG5BC,OAAO,EAAE;AAHmB,CAA9B;AAMA,SAAS9F,MAAT,EAAiBpc,UAAU,IAAImiB,eAA/B,EAAgD1X,KAAK,IAAI2X,MAAzD,EAAiEV,GAAjE,EAAsE/H,cAAtE,EAAsFD,SAAtF,EAAiGE,OAAjG,EAA0GjF,OAA1G,EAAmH1I,UAAnH,EAA+HuI,OAA/H,EAAwImN,YAAxI,EAAsJzU,OAAtJ,EAA+JqN,mBAAmB,IAAIlC,MAAtL,EAA8LnO,MAA9L,EAAsMoE,UAAtM,EAAkN8C,UAAlN,EAA8N4C,MAA9N,EAAsOsJ,sBAAtO,EAA8PQ,QAA9P,EAAwQO,QAAxQ,EAAkRa,SAAlR,EAA6RzB,QAA7R,EAAuSE,QAAvS"},"metadata":{},"sourceType":"module"}